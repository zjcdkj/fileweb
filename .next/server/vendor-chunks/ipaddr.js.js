"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ipaddr.js";
exports.ids = ["vendor-chunks/ipaddr.js"];
exports.modules = {

/***/ "(rsc)/./node_modules/ipaddr.js/lib/ipaddr.js":
/*!**********************************************!*\
  !*** ./node_modules/ipaddr.js/lib/ipaddr.js ***!
  \**********************************************/
/***/ ((module) => {

eval("\n(function(root) {\n    \"use strict\";\n    // A list of regular expressions that match arbitrary IPv4 addresses,\n    // for which a number of weird notations exist.\n    // Note that an address like 0010.0xa5.1.1 is considered legal.\n    const ipv4Part = \"(0?\\\\d+|0x[a-f0-9]+)\";\n    const ipv4Regexes = {\n        fourOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, \"i\"),\n        threeOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}$`, \"i\"),\n        twoOctet: new RegExp(`^${ipv4Part}\\\\.${ipv4Part}$`, \"i\"),\n        longValue: new RegExp(`^${ipv4Part}$`, \"i\")\n    };\n    // Regular Expression for checking Octal numbers\n    const octalRegex = new RegExp(`^0[0-7]+$`, \"i\");\n    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, \"i\");\n    const zoneIndex = \"%[0-9a-z]{1,}\";\n    // IPv6-matching regular expressions.\n    // For IPv6, the task is simpler: it is enough to match the colon-delimited\n    // hexadecimal IPv6 and a transitional variant with dotted-decimal IPv4 at\n    // the end.\n    const ipv6Part = \"(?:[0-9a-f]+::?)+\";\n    const ipv6Regexes = {\n        zoneIndex: new RegExp(zoneIndex, \"i\"),\n        \"native\": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, \"i\"),\n        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?)$`, \"i\"),\n        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}\\\\.${ipv4Part}(${zoneIndex})?$`, \"i\")\n    };\n    // Expand :: in an IPv6 address or address part consisting of `parts` groups.\n    function expandIPv6(string, parts) {\n        // More than one '::' means invalid adddress\n        if (string.indexOf(\"::\") !== string.lastIndexOf(\"::\")) {\n            return null;\n        }\n        let colonCount = 0;\n        let lastColon = -1;\n        let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];\n        let replacement, replacementCount;\n        // Remove zone index and save it for later\n        if (zoneId) {\n            zoneId = zoneId.substring(1);\n            string = string.replace(/%.+$/, \"\");\n        }\n        // How many parts do we already have?\n        while((lastColon = string.indexOf(\":\", lastColon + 1)) >= 0){\n            colonCount++;\n        }\n        // 0::0 is two parts more than ::\n        if (string.substr(0, 2) === \"::\") {\n            colonCount--;\n        }\n        if (string.substr(-2, 2) === \"::\") {\n            colonCount--;\n        }\n        // The following loop would hang if colonCount > parts\n        if (colonCount > parts) {\n            return null;\n        }\n        // replacement = ':' + '0:' * (parts - colonCount)\n        replacementCount = parts - colonCount;\n        replacement = \":\";\n        while(replacementCount--){\n            replacement += \"0:\";\n        }\n        // Insert the missing zeroes\n        string = string.replace(\"::\", replacement);\n        // Trim any garbage which may be hanging around if :: was at the edge in\n        // the source strin\n        if (string[0] === \":\") {\n            string = string.slice(1);\n        }\n        if (string[string.length - 1] === \":\") {\n            string = string.slice(0, -1);\n        }\n        parts = function() {\n            const ref = string.split(\":\");\n            const results = [];\n            for(let i = 0; i < ref.length; i++){\n                results.push(parseInt(ref[i], 16));\n            }\n            return results;\n        }();\n        return {\n            parts: parts,\n            zoneId: zoneId\n        };\n    }\n    // A generic CIDR (Classless Inter-Domain Routing) RFC1518 range matcher.\n    function matchCIDR(first, second, partSize, cidrBits) {\n        if (first.length !== second.length) {\n            throw new Error(\"ipaddr: cannot match CIDR for objects with different lengths\");\n        }\n        let part = 0;\n        let shift;\n        while(cidrBits > 0){\n            shift = partSize - cidrBits;\n            if (shift < 0) {\n                shift = 0;\n            }\n            if (first[part] >> shift !== second[part] >> shift) {\n                return false;\n            }\n            cidrBits -= partSize;\n            part += 1;\n        }\n        return true;\n    }\n    function parseIntAuto(string) {\n        // Hexadedimal base 16 (0x#)\n        if (hexRegex.test(string)) {\n            return parseInt(string, 16);\n        }\n        // While octal representation is discouraged by ECMAScript 3\n        // and forbidden by ECMAScript 5, we silently allow it to\n        // work only if the rest of the string has numbers less than 8.\n        if (string[0] === \"0\" && !isNaN(parseInt(string[1], 10))) {\n            if (octalRegex.test(string)) {\n                return parseInt(string, 8);\n            }\n            throw new Error(`ipaddr: cannot parse ${string} as octal`);\n        }\n        // Always include the base 10 radix!\n        return parseInt(string, 10);\n    }\n    function padPart(part, length) {\n        while(part.length < length){\n            part = `0${part}`;\n        }\n        return part;\n    }\n    const ipaddr = {};\n    // An IPv4 address (RFC791).\n    ipaddr.IPv4 = function() {\n        // Constructs a new IPv4 address from an array of four octets\n        // in network order (MSB first)\n        // Verifies the input.\n        function IPv4(octets) {\n            if (octets.length !== 4) {\n                throw new Error(\"ipaddr: ipv4 octet count should be 4\");\n            }\n            let i, octet;\n            for(i = 0; i < octets.length; i++){\n                octet = octets[i];\n                if (!(0 <= octet && octet <= 255)) {\n                    throw new Error(\"ipaddr: ipv4 octet should fit in 8 bits\");\n                }\n            }\n            this.octets = octets;\n        }\n        // Special IPv4 address ranges.\n        // See also https://en.wikipedia.org/wiki/Reserved_IP_addresses\n        IPv4.prototype.SpecialRanges = {\n            unspecified: [\n                [\n                    new IPv4([\n                        0,\n                        0,\n                        0,\n                        0\n                    ]),\n                    8\n                ]\n            ],\n            broadcast: [\n                [\n                    new IPv4([\n                        255,\n                        255,\n                        255,\n                        255\n                    ]),\n                    32\n                ]\n            ],\n            // RFC3171\n            multicast: [\n                [\n                    new IPv4([\n                        224,\n                        0,\n                        0,\n                        0\n                    ]),\n                    4\n                ]\n            ],\n            // RFC3927\n            linkLocal: [\n                [\n                    new IPv4([\n                        169,\n                        254,\n                        0,\n                        0\n                    ]),\n                    16\n                ]\n            ],\n            // RFC5735\n            loopback: [\n                [\n                    new IPv4([\n                        127,\n                        0,\n                        0,\n                        0\n                    ]),\n                    8\n                ]\n            ],\n            // RFC6598\n            carrierGradeNat: [\n                [\n                    new IPv4([\n                        100,\n                        64,\n                        0,\n                        0\n                    ]),\n                    10\n                ]\n            ],\n            // RFC1918\n            \"private\": [\n                [\n                    new IPv4([\n                        10,\n                        0,\n                        0,\n                        0\n                    ]),\n                    8\n                ],\n                [\n                    new IPv4([\n                        172,\n                        16,\n                        0,\n                        0\n                    ]),\n                    12\n                ],\n                [\n                    new IPv4([\n                        192,\n                        168,\n                        0,\n                        0\n                    ]),\n                    16\n                ]\n            ],\n            // Reserved and testing-only ranges; RFCs 5735, 5737, 2544, 1700\n            reserved: [\n                [\n                    new IPv4([\n                        192,\n                        0,\n                        0,\n                        0\n                    ]),\n                    24\n                ],\n                [\n                    new IPv4([\n                        192,\n                        0,\n                        2,\n                        0\n                    ]),\n                    24\n                ],\n                [\n                    new IPv4([\n                        192,\n                        88,\n                        99,\n                        0\n                    ]),\n                    24\n                ],\n                [\n                    new IPv4([\n                        198,\n                        18,\n                        0,\n                        0\n                    ]),\n                    15\n                ],\n                [\n                    new IPv4([\n                        198,\n                        51,\n                        100,\n                        0\n                    ]),\n                    24\n                ],\n                [\n                    new IPv4([\n                        203,\n                        0,\n                        113,\n                        0\n                    ]),\n                    24\n                ],\n                [\n                    new IPv4([\n                        240,\n                        0,\n                        0,\n                        0\n                    ]),\n                    4\n                ]\n            ],\n            // RFC7534, RFC7535\n            as112: [\n                [\n                    new IPv4([\n                        192,\n                        175,\n                        48,\n                        0\n                    ]),\n                    24\n                ],\n                [\n                    new IPv4([\n                        192,\n                        31,\n                        196,\n                        0\n                    ]),\n                    24\n                ]\n            ],\n            // RFC7450\n            amt: [\n                [\n                    new IPv4([\n                        192,\n                        52,\n                        193,\n                        0\n                    ]),\n                    24\n                ]\n            ]\n        };\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv4.prototype.kind = function() {\n            return \"ipv4\";\n        };\n        // Checks if this address matches other one within given CIDR range.\n        IPv4.prototype.match = function(other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n            if (other.kind() !== \"ipv4\") {\n                throw new Error(\"ipaddr: cannot match ipv4 address with non-ipv4 one\");\n            }\n            return matchCIDR(this.octets, other.octets, 8, cidrRange);\n        };\n        // returns a number of leading ones in IPv4 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv4.prototype.prefixLengthFromSubnetMask = function() {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 8,\n                128: 7,\n                192: 6,\n                224: 5,\n                240: 4,\n                248: 3,\n                252: 2,\n                254: 1,\n                255: 0\n            };\n            let i, octet, zeros;\n            for(i = 3; i >= 0; i -= 1){\n                octet = this.octets[i];\n                if (octet in zerotable) {\n                    zeros = zerotable[octet];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n                    if (zeros !== 8) {\n                        stop = true;\n                    }\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n            return 32 - cidr;\n        };\n        // Checks if the address corresponds to one of the special ranges.\n        IPv4.prototype.range = function() {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv4.prototype.toByteArray = function() {\n            return this.octets.slice(0);\n        };\n        // Converts this IPv4 address to an IPv4-mapped IPv6 address.\n        IPv4.prototype.toIPv4MappedAddress = function() {\n            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);\n        };\n        // Symmetrical method strictly for aligning with the IPv6 methods.\n        IPv4.prototype.toNormalizedString = function() {\n            return this.toString();\n        };\n        // Returns the address in convenient, decimal-dotted format.\n        IPv4.prototype.toString = function() {\n            return this.octets.join(\".\");\n        };\n        return IPv4;\n    }();\n    // A utility function to return broadcast address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while(i < 4){\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n            return new this(octets);\n        } catch (e) {\n            throw new Error(\"ipaddr: the address does not have IPv4 CIDR format\");\n        }\n    };\n    // Checks if a given string is formatted like IPv4 address.\n    ipaddr.IPv4.isIPv4 = function(string) {\n        return this.parser(string) !== null;\n    };\n    // Checks if a given string is a valid IPv4 address.\n    ipaddr.IPv4.isValid = function(string) {\n        try {\n            new this(this.parser(string));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n    // Checks if a given string is a valid IPv4 address in CIDR notation.\n    ipaddr.IPv4.isValidCIDR = function(string) {\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n    // Checks if a given string is a full four-part IPv4 Address.\n    ipaddr.IPv4.isValidFourPartDecimal = function(string) {\n        if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){3}$/)) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n    // A utility function to return network address given the IPv4 interface and prefix length in CIDR notation\n    ipaddr.IPv4.networkAddressFromCIDR = function(string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while(i < 4){\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n            return new this(octets);\n        } catch (e) {\n            throw new Error(\"ipaddr: the address does not have IPv4 CIDR format\");\n        }\n    };\n    // Tries to parse and validate a string with IPv4 address.\n    // Throws an error if it fails.\n    ipaddr.IPv4.parse = function(string) {\n        const parts = this.parser(string);\n        if (parts === null) {\n            throw new Error(\"ipaddr: string is not formatted like an IPv4 Address\");\n        }\n        return new this(parts);\n    };\n    // Parses the string as an IPv4 Address with CIDR Notation.\n    ipaddr.IPv4.parseCIDR = function(string) {\n        let match;\n        if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n            const maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 32) {\n                const parsed = [\n                    this.parse(match[1]),\n                    maskLength\n                ];\n                Object.defineProperty(parsed, \"toString\", {\n                    value: function() {\n                        return this.join(\"/\");\n                    }\n                });\n                return parsed;\n            }\n        }\n        throw new Error(\"ipaddr: string is not formatted like an IPv4 CIDR range\");\n    };\n    // Classful variants (like a.b, where a is an octet, and b is a 24-bit\n    // value representing last three octets; this corresponds to a class C\n    // address) are omitted due to classless nature of modern Internet.\n    ipaddr.IPv4.parser = function(string) {\n        let match, part, value;\n        // parseInt recognizes all that octal & hexadecimal weirdness for us\n        if (match = string.match(ipv4Regexes.fourOctet)) {\n            return function() {\n                const ref = match.slice(1, 6);\n                const results = [];\n                for(let i = 0; i < ref.length; i++){\n                    part = ref[i];\n                    results.push(parseIntAuto(part));\n                }\n                return results;\n            }();\n        } else if (match = string.match(ipv4Regexes.longValue)) {\n            value = parseIntAuto(match[1]);\n            if (value > 0xffffffff || value < 0) {\n                throw new Error(\"ipaddr: address outside defined range\");\n            }\n            return (function() {\n                const results = [];\n                let shift;\n                for(shift = 0; shift <= 24; shift += 8){\n                    results.push(value >> shift & 0xff);\n                }\n                return results;\n            })().reverse();\n        } else if (match = string.match(ipv4Regexes.twoOctet)) {\n            return function() {\n                const ref = match.slice(1, 4);\n                const results = [];\n                value = parseIntAuto(ref[1]);\n                if (value > 0xffffff || value < 0) {\n                    throw new Error(\"ipaddr: address outside defined range\");\n                }\n                results.push(parseIntAuto(ref[0]));\n                results.push(value >> 16 & 0xff);\n                results.push(value >> 8 & 0xff);\n                results.push(value & 0xff);\n                return results;\n            }();\n        } else if (match = string.match(ipv4Regexes.threeOctet)) {\n            return function() {\n                const ref = match.slice(1, 5);\n                const results = [];\n                value = parseIntAuto(ref[2]);\n                if (value > 0xffff || value < 0) {\n                    throw new Error(\"ipaddr: address outside defined range\");\n                }\n                results.push(parseIntAuto(ref[0]));\n                results.push(parseIntAuto(ref[1]));\n                results.push(value >> 8 & 0xff);\n                results.push(value & 0xff);\n                return results;\n            }();\n        } else {\n            return null;\n        }\n    };\n    // A utility function to return subnet mask in IPv4 format given the prefix length\n    ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 32) {\n            throw new Error(\"ipaddr: invalid IPv4 prefix length\");\n        }\n        const octets = [\n            0,\n            0,\n            0,\n            0\n        ];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n        while(j < filledOctetCount){\n            octets[j] = 255;\n            j++;\n        }\n        if (filledOctetCount < 4) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;\n        }\n        return new this(octets);\n    };\n    // An IPv6 address (RFC2460)\n    ipaddr.IPv6 = function() {\n        // Constructs an IPv6 address from an array of eight 16 - bit parts\n        // or sixteen 8 - bit parts in network order(MSB first).\n        // Throws an error if the input is invalid.\n        function IPv6(parts, zoneId) {\n            let i, part;\n            if (parts.length === 16) {\n                this.parts = [];\n                for(i = 0; i <= 14; i += 2){\n                    this.parts.push(parts[i] << 8 | parts[i + 1]);\n                }\n            } else if (parts.length === 8) {\n                this.parts = parts;\n            } else {\n                throw new Error(\"ipaddr: ipv6 part count should be 8 or 16\");\n            }\n            for(i = 0; i < this.parts.length; i++){\n                part = this.parts[i];\n                if (!(0 <= part && part <= 0xffff)) {\n                    throw new Error(\"ipaddr: ipv6 part should fit in 16 bits\");\n                }\n            }\n            if (zoneId) {\n                this.zoneId = zoneId;\n            }\n        }\n        // Special IPv6 ranges\n        IPv6.prototype.SpecialRanges = {\n            // RFC4291, here and after\n            unspecified: [\n                new IPv6([\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                128\n            ],\n            linkLocal: [\n                new IPv6([\n                    0xfe80,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                10\n            ],\n            multicast: [\n                new IPv6([\n                    0xff00,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                8\n            ],\n            loopback: [\n                new IPv6([\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ]),\n                128\n            ],\n            uniqueLocal: [\n                new IPv6([\n                    0xfc00,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                7\n            ],\n            ipv4Mapped: [\n                new IPv6([\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0xffff,\n                    0,\n                    0\n                ]),\n                96\n            ],\n            // RFC6666\n            discard: [\n                new IPv6([\n                    0x100,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                64\n            ],\n            // RFC6145\n            rfc6145: [\n                new IPv6([\n                    0,\n                    0,\n                    0,\n                    0,\n                    0xffff,\n                    0,\n                    0,\n                    0\n                ]),\n                96\n            ],\n            // RFC6052\n            rfc6052: [\n                new IPv6([\n                    0x64,\n                    0xff9b,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                96\n            ],\n            // RFC3056\n            \"6to4\": [\n                new IPv6([\n                    0x2002,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                16\n            ],\n            // RFC6052, RFC6146\n            teredo: [\n                new IPv6([\n                    0x2001,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                32\n            ],\n            // RFC5180\n            benchmarking: [\n                new IPv6([\n                    0x2001,\n                    0x2,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                48\n            ],\n            // RFC7450\n            amt: [\n                new IPv6([\n                    0x2001,\n                    0x3,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                32\n            ],\n            as112v6: [\n                [\n                    new IPv6([\n                        0x2001,\n                        0x4,\n                        0x112,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0\n                    ]),\n                    48\n                ],\n                [\n                    new IPv6([\n                        0x2620,\n                        0x4f,\n                        0x8000,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0\n                    ]),\n                    48\n                ]\n            ],\n            deprecated: [\n                new IPv6([\n                    0x2001,\n                    0x10,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                28\n            ],\n            orchid2: [\n                new IPv6([\n                    0x2001,\n                    0x20,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                28\n            ],\n            droneRemoteIdProtocolEntityTags: [\n                new IPv6([\n                    0x2001,\n                    0x30,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ]),\n                28\n            ],\n            reserved: [\n                // RFC3849\n                [\n                    new IPv6([\n                        0x2001,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0\n                    ]),\n                    23\n                ],\n                // RFC2928\n                [\n                    new IPv6([\n                        0x2001,\n                        0xdb8,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0\n                    ]),\n                    32\n                ]\n            ]\n        };\n        // Checks if this address is an IPv4-mapped IPv6 address.\n        IPv6.prototype.isIPv4MappedAddress = function() {\n            return this.range() === \"ipv4Mapped\";\n        };\n        // The 'kind' method exists on both IPv4 and IPv6 classes.\n        IPv6.prototype.kind = function() {\n            return \"ipv6\";\n        };\n        // Checks if this address matches other one within given CIDR range.\n        IPv6.prototype.match = function(other, cidrRange) {\n            let ref;\n            if (cidrRange === undefined) {\n                ref = other;\n                other = ref[0];\n                cidrRange = ref[1];\n            }\n            if (other.kind() !== \"ipv6\") {\n                throw new Error(\"ipaddr: cannot match ipv6 address with non-ipv6 one\");\n            }\n            return matchCIDR(this.parts, other.parts, 16, cidrRange);\n        };\n        // returns a number of leading ones in IPv6 address, making sure that\n        // the rest is a solid sequence of 0's (valid netmask)\n        // returns either the CIDR length or null if mask is not valid\n        IPv6.prototype.prefixLengthFromSubnetMask = function() {\n            let cidr = 0;\n            // non-zero encountered stop scanning for zeroes\n            let stop = false;\n            // number of zeroes in octet\n            const zerotable = {\n                0: 16,\n                32768: 15,\n                49152: 14,\n                57344: 13,\n                61440: 12,\n                63488: 11,\n                64512: 10,\n                65024: 9,\n                65280: 8,\n                65408: 7,\n                65472: 6,\n                65504: 5,\n                65520: 4,\n                65528: 3,\n                65532: 2,\n                65534: 1,\n                65535: 0\n            };\n            let part, zeros;\n            for(let i = 7; i >= 0; i -= 1){\n                part = this.parts[i];\n                if (part in zerotable) {\n                    zeros = zerotable[part];\n                    if (stop && zeros !== 0) {\n                        return null;\n                    }\n                    if (zeros !== 16) {\n                        stop = true;\n                    }\n                    cidr += zeros;\n                } else {\n                    return null;\n                }\n            }\n            return 128 - cidr;\n        };\n        // Checks if the address corresponds to one of the special ranges.\n        IPv6.prototype.range = function() {\n            return ipaddr.subnetMatch(this, this.SpecialRanges);\n        };\n        // Returns an array of byte-sized values in network order (MSB first)\n        IPv6.prototype.toByteArray = function() {\n            let part;\n            const bytes = [];\n            const ref = this.parts;\n            for(let i = 0; i < ref.length; i++){\n                part = ref[i];\n                bytes.push(part >> 8);\n                bytes.push(part & 0xff);\n            }\n            return bytes;\n        };\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:0db8:0008:0066:0000:0000:0000:0001\n        IPv6.prototype.toFixedLengthString = function() {\n            const addr = (function() {\n                const results = [];\n                for(let i = 0; i < this.parts.length; i++){\n                    results.push(padPart(this.parts[i].toString(16), 4));\n                }\n                return results;\n            }).call(this).join(\":\");\n            let suffix = \"\";\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n            return addr + suffix;\n        };\n        // Converts this address to IPv4 address if it is an IPv4-mapped IPv6 address.\n        // Throws an error otherwise.\n        IPv6.prototype.toIPv4Address = function() {\n            if (!this.isIPv4MappedAddress()) {\n                throw new Error(\"ipaddr: trying to convert a generic ipv6 address to ipv4\");\n            }\n            const ref = this.parts.slice(-2);\n            const high = ref[0];\n            const low = ref[1];\n            return new ipaddr.IPv4([\n                high >> 8,\n                high & 0xff,\n                low >> 8,\n                low & 0xff\n            ]);\n        };\n        // Returns the address in expanded format with all zeroes included, like\n        // 2001:db8:8:66:0:0:0:1\n        //\n        // Deprecated: use toFixedLengthString() instead.\n        IPv6.prototype.toNormalizedString = function() {\n            const addr = (function() {\n                const results = [];\n                for(let i = 0; i < this.parts.length; i++){\n                    results.push(this.parts[i].toString(16));\n                }\n                return results;\n            }).call(this).join(\":\");\n            let suffix = \"\";\n            if (this.zoneId) {\n                suffix = `%${this.zoneId}`;\n            }\n            return addr + suffix;\n        };\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // in line with RFC 5952 (see https://tools.ietf.org/html/rfc5952#section-4)\n        IPv6.prototype.toRFC5952String = function() {\n            const regex = /((^|:)(0(:|$)){2,})/g;\n            const string = this.toNormalizedString();\n            let bestMatchIndex = 0;\n            let bestMatchLength = -1;\n            let match;\n            while(match = regex.exec(string)){\n                if (match[0].length > bestMatchLength) {\n                    bestMatchIndex = match.index;\n                    bestMatchLength = match[0].length;\n                }\n            }\n            if (bestMatchLength < 0) {\n                return string;\n            }\n            return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;\n        };\n        // Returns the address in compact, human-readable format like\n        // 2001:db8:8:66::1\n        // Calls toRFC5952String under the hood.\n        IPv6.prototype.toString = function() {\n            return this.toRFC5952String();\n        };\n        return IPv6;\n    }();\n    // A utility function to return broadcast address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.broadcastAddressFromCIDR = function(string) {\n        try {\n            const cidr = this.parseCIDR(string);\n            const ipInterfaceOctets = cidr[0].toByteArray();\n            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            const octets = [];\n            let i = 0;\n            while(i < 16){\n                // Broadcast address is bitwise OR between ip interface and inverted mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);\n                i++;\n            }\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n    // Checks if a given string is formatted like IPv6 address.\n    ipaddr.IPv6.isIPv6 = function(string) {\n        return this.parser(string) !== null;\n    };\n    // Checks to see if string is a valid IPv6 Address\n    ipaddr.IPv6.isValid = function(string) {\n        // Since IPv6.isValid is always called first, this shortcut\n        // provides a substantial performance gain.\n        if (typeof string === \"string\" && string.indexOf(\":\") === -1) {\n            return false;\n        }\n        try {\n            const addr = this.parser(string);\n            new this(addr.parts, addr.zoneId);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n    // Checks if a given string is a valid IPv6 address in CIDR notation.\n    ipaddr.IPv6.isValidCIDR = function(string) {\n        // See note in IPv6.isValid\n        if (typeof string === \"string\" && string.indexOf(\":\") === -1) {\n            return false;\n        }\n        try {\n            this.parseCIDR(string);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    };\n    // A utility function to return network address given the IPv6 interface and prefix length in CIDR notation\n    ipaddr.IPv6.networkAddressFromCIDR = function(string) {\n        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;\n        try {\n            cidr = this.parseCIDR(string);\n            ipInterfaceOctets = cidr[0].toByteArray();\n            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();\n            octets = [];\n            i = 0;\n            while(i < 16){\n                // Network address is bitwise AND between ip interface and mask\n                octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));\n                i++;\n            }\n            return new this(octets);\n        } catch (e) {\n            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);\n        }\n    };\n    // Tries to parse and validate a string with IPv6 address.\n    // Throws an error if it fails.\n    ipaddr.IPv6.parse = function(string) {\n        const addr = this.parser(string);\n        if (addr.parts === null) {\n            throw new Error(\"ipaddr: string is not formatted like an IPv6 Address\");\n        }\n        return new this(addr.parts, addr.zoneId);\n    };\n    ipaddr.IPv6.parseCIDR = function(string) {\n        let maskLength, match, parsed;\n        if (match = string.match(/^(.+)\\/(\\d+)$/)) {\n            maskLength = parseInt(match[2]);\n            if (maskLength >= 0 && maskLength <= 128) {\n                parsed = [\n                    this.parse(match[1]),\n                    maskLength\n                ];\n                Object.defineProperty(parsed, \"toString\", {\n                    value: function() {\n                        return this.join(\"/\");\n                    }\n                });\n                return parsed;\n            }\n        }\n        throw new Error(\"ipaddr: string is not formatted like an IPv6 CIDR range\");\n    };\n    // Parse an IPv6 address.\n    ipaddr.IPv6.parser = function(string) {\n        let addr, i, match, octet, octets, zoneId;\n        if (match = string.match(ipv6Regexes.deprecatedTransitional)) {\n            return this.parser(`::ffff:${match[1]}`);\n        }\n        if (ipv6Regexes.native.test(string)) {\n            return expandIPv6(string, 8);\n        }\n        if (match = string.match(ipv6Regexes.transitional)) {\n            zoneId = match[6] || \"\";\n            addr = match[1];\n            if (!match[1].endsWith(\"::\")) {\n                addr = addr.slice(0, -1);\n            }\n            addr = expandIPv6(addr + zoneId, 6);\n            if (addr.parts) {\n                octets = [\n                    parseInt(match[2]),\n                    parseInt(match[3]),\n                    parseInt(match[4]),\n                    parseInt(match[5])\n                ];\n                for(i = 0; i < octets.length; i++){\n                    octet = octets[i];\n                    if (!(0 <= octet && octet <= 255)) {\n                        return null;\n                    }\n                }\n                addr.parts.push(octets[0] << 8 | octets[1]);\n                addr.parts.push(octets[2] << 8 | octets[3]);\n                return {\n                    parts: addr.parts,\n                    zoneId: addr.zoneId\n                };\n            }\n        }\n        return null;\n    };\n    // A utility function to return subnet mask in IPv6 format given the prefix length\n    ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {\n        prefix = parseInt(prefix);\n        if (prefix < 0 || prefix > 128) {\n            throw new Error(\"ipaddr: invalid IPv6 prefix length\");\n        }\n        const octets = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ];\n        let j = 0;\n        const filledOctetCount = Math.floor(prefix / 8);\n        while(j < filledOctetCount){\n            octets[j] = 255;\n            j++;\n        }\n        if (filledOctetCount < 16) {\n            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;\n        }\n        return new this(octets);\n    };\n    // Try to parse an array in network order (MSB first) for IPv4 and IPv6\n    ipaddr.fromByteArray = function(bytes) {\n        const length = bytes.length;\n        if (length === 4) {\n            return new ipaddr.IPv4(bytes);\n        } else if (length === 16) {\n            return new ipaddr.IPv6(bytes);\n        } else {\n            throw new Error(\"ipaddr: the binary input is neither an IPv6 nor IPv4 address\");\n        }\n    };\n    // Checks if the address is valid IP address\n    ipaddr.isValid = function(string) {\n        return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);\n    };\n    // Checks if the address is valid IP address in CIDR notation\n    ipaddr.isValidCIDR = function(string) {\n        return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);\n    };\n    // Attempts to parse an IP Address, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parse = function(string) {\n        if (ipaddr.IPv6.isValid(string)) {\n            return ipaddr.IPv6.parse(string);\n        } else if (ipaddr.IPv4.isValid(string)) {\n            return ipaddr.IPv4.parse(string);\n        } else {\n            throw new Error(\"ipaddr: the address has neither IPv6 nor IPv4 format\");\n        }\n    };\n    // Attempt to parse CIDR notation, first through IPv6 then IPv4.\n    // Throws an error if it could not be parsed.\n    ipaddr.parseCIDR = function(string) {\n        try {\n            return ipaddr.IPv6.parseCIDR(string);\n        } catch (e) {\n            try {\n                return ipaddr.IPv4.parseCIDR(string);\n            } catch (e2) {\n                throw new Error(\"ipaddr: the address has neither IPv6 nor IPv4 CIDR format\");\n            }\n        }\n    };\n    // Parse an address and return plain IPv4 address if it is an IPv4-mapped address\n    ipaddr.process = function(string) {\n        const addr = this.parse(string);\n        if (addr.kind() === \"ipv6\" && addr.isIPv4MappedAddress()) {\n            return addr.toIPv4Address();\n        } else {\n            return addr;\n        }\n    };\n    // An utility function to ease named range matching. See examples below.\n    // rangeList can contain both IPv4 and IPv6 subnet entries and will not throw errors\n    // on matching IPv4 addresses to IPv6 ranges or vice versa.\n    ipaddr.subnetMatch = function(address, rangeList, defaultName) {\n        let i, rangeName, rangeSubnets, subnet;\n        if (defaultName === undefined || defaultName === null) {\n            defaultName = \"unicast\";\n        }\n        for(rangeName in rangeList){\n            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {\n                rangeSubnets = rangeList[rangeName];\n                // ECMA5 Array.isArray isn't available everywhere\n                if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {\n                    rangeSubnets = [\n                        rangeSubnets\n                    ];\n                }\n                for(i = 0; i < rangeSubnets.length; i++){\n                    subnet = rangeSubnets[i];\n                    if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {\n                        return rangeName;\n                    }\n                }\n            }\n        }\n        return defaultName;\n    };\n    // Export for both the CommonJS and browser-like environment\n    if ( true && module.exports) {\n        module.exports = ipaddr;\n    } else {\n        root.ipaddr = ipaddr;\n    }\n})(void 0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaXBhZGRyLmpzL2xpYi9pcGFkZHIuanMiLCJtYXBwaW5ncyI6IjtBQUFDLFVBQVVBLElBQUk7SUFDWDtJQUNBLHFFQUFxRTtJQUNyRSwrQ0FBK0M7SUFDL0MsK0RBQStEO0lBQy9ELE1BQU1DLFdBQVc7SUFDakIsTUFBTUMsY0FBYztRQUNoQkMsV0FBVyxJQUFJQyxPQUFPLENBQUMsQ0FBQyxFQUFFSCxTQUFTLEdBQUcsRUFBRUEsU0FBUyxHQUFHLEVBQUVBLFNBQVMsR0FBRyxFQUFFQSxTQUFTLENBQUMsQ0FBQyxFQUFFO1FBQ2pGSSxZQUFZLElBQUlELE9BQU8sQ0FBQyxDQUFDLEVBQUVILFNBQVMsR0FBRyxFQUFFQSxTQUFTLEdBQUcsRUFBRUEsU0FBUyxDQUFDLENBQUMsRUFBRTtRQUNwRUssVUFBVSxJQUFJRixPQUFPLENBQUMsQ0FBQyxFQUFFSCxTQUFTLEdBQUcsRUFBRUEsU0FBUyxDQUFDLENBQUMsRUFBRTtRQUNwRE0sV0FBVyxJQUFJSCxPQUFPLENBQUMsQ0FBQyxFQUFFSCxTQUFTLENBQUMsQ0FBQyxFQUFFO0lBQzNDO0lBRUEsZ0RBQWdEO0lBQ2hELE1BQU1PLGFBQWEsSUFBSUosT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFO0lBQzNDLE1BQU1LLFdBQVcsSUFBSUwsT0FBTyxDQUFDLGFBQWEsQ0FBQyxFQUFFO0lBRTdDLE1BQU1NLFlBQVk7SUFFbEIscUNBQXFDO0lBQ3JDLDJFQUEyRTtJQUMzRSwwRUFBMEU7SUFDMUUsV0FBVztJQUNYLE1BQU1DLFdBQVc7SUFDakIsTUFBTUMsY0FBYztRQUNoQkYsV0FBVyxJQUFJTixPQUFPTSxXQUFXO1FBQ2pDLFVBQVUsSUFBSU4sT0FBTyxDQUFDLE9BQU8sRUFBRU8sU0FBUyxvQkFBb0IsRUFBRUQsVUFBVSxHQUFHLENBQUMsRUFBRTtRQUM5RUcsd0JBQXdCLElBQUlULE9BQU8sQ0FBQyxRQUFRLEVBQUVILFNBQVMsR0FBRyxFQUFFQSxTQUFTLEdBQUcsRUFBRUEsU0FB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T0FBTyxFQUFFQyxTQUFTLEVBQUVDLFdBQVc7UUFDMUQsSUFBSTFHLEdBQUcyRyxXQUFXQyxjQUFjQztRQUVoQyxJQUFJSCxnQkFBZ0J6RSxhQUFheUUsZ0JBQWdCLE1BQU07WUFDbkRBLGNBQWM7UUFDbEI7UUFFQSxJQUFLQyxhQUFhRixVQUFXO1lBQ3pCLElBQUkzQyxPQUFPM0MsU0FBUyxDQUFDMkYsY0FBYyxDQUFDdkIsSUFBSSxDQUFDa0IsV0FBV0UsWUFBWTtnQkFDNURDLGVBQWVILFNBQVMsQ0FBQ0UsVUFBVTtnQkFDbkMsaURBQWlEO2dCQUNqRCxJQUFJQyxZQUFZLENBQUMsRUFBRSxJQUFJLENBQUVBLENBQUFBLFlBQVksQ0FBQyxFQUFFLFlBQVlHLEtBQUksR0FBSTtvQkFDeERILGVBQWU7d0JBQUNBO3FCQUFhO2dCQUNqQztnQkFFQSxJQUFLNUcsSUFBSSxHQUFHQSxJQUFJNEcsYUFBYWhILE1BQU0sRUFBRUksSUFBSztvQkFDdEM2RyxTQUFTRCxZQUFZLENBQUM1RyxFQUFFO29CQUN4QixJQUFJd0csUUFBUTFFLElBQUksT0FBTytFLE1BQU0sQ0FBQyxFQUFFLENBQUMvRSxJQUFJLE1BQU0wRSxRQUFRbkgsS0FBSyxDQUFDMkgsS0FBSyxDQUFDUixTQUFTSyxTQUFTO3dCQUM3RSxPQUFPRjtvQkFDWDtnQkFDSjtZQUNKO1FBQ0o7UUFFQSxPQUFPRDtJQUNYO0lBRUEsNERBQTREO0lBQzVELElBQUksS0FBa0IsSUFBZU8sT0FBT0MsT0FBTyxFQUFFO1FBQ2pERCxPQUFPQyxPQUFPLEdBQUduRztJQUVyQixPQUFPO1FBQ0hqRCxLQUFLaUQsTUFBTSxHQUFHQTtJQUNsQjtBQUVKLEdBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9maWxlLW1hbmFnZW1lbnQtc3lzdGVtLy4vbm9kZV9tb2R1bGVzL2lwYWRkci5qcy9saWIvaXBhZGRyLmpzPzZiMTYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChyb290KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIC8vIEEgbGlzdCBvZiByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggYXJiaXRyYXJ5IElQdjQgYWRkcmVzc2VzLFxuICAgIC8vIGZvciB3aGljaCBhIG51bWJlciBvZiB3ZWlyZCBub3RhdGlvbnMgZXhpc3QuXG4gICAgLy8gTm90ZSB0aGF0IGFuIGFkZHJlc3MgbGlrZSAwMDEwLjB4YTUuMS4xIGlzIGNvbnNpZGVyZWQgbGVnYWwuXG4gICAgY29uc3QgaXB2NFBhcnQgPSAnKDA/XFxcXGQrfDB4W2EtZjAtOV0rKSc7XG4gICAgY29uc3QgaXB2NFJlZ2V4ZXMgPSB7XG4gICAgICAgIGZvdXJPY3RldDogbmV3IFJlZ0V4cChgXiR7aXB2NFBhcnR9XFxcXC4ke2lwdjRQYXJ0fVxcXFwuJHtpcHY0UGFydH1cXFxcLiR7aXB2NFBhcnR9JGAsICdpJyksXG4gICAgICAgIHRocmVlT2N0ZXQ6IG5ldyBSZWdFeHAoYF4ke2lwdjRQYXJ0fVxcXFwuJHtpcHY0UGFydH1cXFxcLiR7aXB2NFBhcnR9JGAsICdpJyksXG4gICAgICAgIHR3b09jdGV0OiBuZXcgUmVnRXhwKGBeJHtpcHY0UGFydH1cXFxcLiR7aXB2NFBhcnR9JGAsICdpJyksXG4gICAgICAgIGxvbmdWYWx1ZTogbmV3IFJlZ0V4cChgXiR7aXB2NFBhcnR9JGAsICdpJylcbiAgICB9O1xuXG4gICAgLy8gUmVndWxhciBFeHByZXNzaW9uIGZvciBjaGVja2luZyBPY3RhbCBudW1iZXJzXG4gICAgY29uc3Qgb2N0YWxSZWdleCA9IG5ldyBSZWdFeHAoYF4wWzAtN10rJGAsICdpJyk7XG4gICAgY29uc3QgaGV4UmVnZXggPSBuZXcgUmVnRXhwKGBeMHhbYS1mMC05XSskYCwgJ2knKTtcblxuICAgIGNvbnN0IHpvbmVJbmRleCA9ICclWzAtOWEtel17MSx9JztcblxuICAgIC8vIElQdjYtbWF0Y2hpbmcgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAvLyBGb3IgSVB2NiwgdGhlIHRhc2sgaXMgc2ltcGxlcjogaXQgaXMgZW5vdWdoIHRvIG1hdGNoIHRoZSBjb2xvbi1kZWxpbWl0ZWRcbiAgICAvLyBoZXhhZGVjaW1hbCBJUHY2IGFuZCBhIHRyYW5zaXRpb25hbCB2YXJpYW50IHdpdGggZG90dGVkLWRlY2ltYWwgSVB2NCBhdFxuICAgIC8vIHRoZSBlbmQuXG4gICAgY29uc3QgaXB2NlBhcnQgPSAnKD86WzAtOWEtZl0rOjo/KSsnO1xuICAgIGNvbnN0IGlwdjZSZWdleGVzID0ge1xuICAgICAgICB6b25lSW5kZXg6IG5ldyBSZWdFeHAoem9uZUluZGV4LCAnaScpLFxuICAgICAgICAnbmF0aXZlJzogbmV3IFJlZ0V4cChgXig6Oik/KCR7aXB2NlBhcnR9KT8oWzAtOWEtZl0rKT8oOjopPygke3pvbmVJbmRleH0pPyRgLCAnaScpLFxuICAgICAgICBkZXByZWNhdGVkVHJhbnNpdGlvbmFsOiBuZXcgUmVnRXhwKGBeKD86OjopKCR7aXB2NFBhcnR9XFxcXC4ke2lwdjRQYXJ0fVxcXFwuJHtpcHY0UGFydH1cXFxcLiR7aXB2NFBhcnR9KCR7em9uZUluZGV4fSk/KSRgLCAnaScpLFxuICAgICAgICB0cmFuc2l0aW9uYWw6IG5ldyBSZWdFeHAoYF4oKD86JHtpcHY2UGFydH0pfCg/Ojo6KSg/OiR7aXB2NlBhcnR9KT8pJHtpcHY0UGFydH1cXFxcLiR7aXB2NFBhcnR9XFxcXC4ke2lwdjRQYXJ0fVxcXFwuJHtpcHY0UGFydH0oJHt6b25lSW5kZXh9KT8kYCwgJ2knKVxuICAgIH07XG5cbiAgICAvLyBFeHBhbmQgOjogaW4gYW4gSVB2NiBhZGRyZXNzIG9yIGFkZHJlc3MgcGFydCBjb25zaXN0aW5nIG9mIGBwYXJ0c2AgZ3JvdXBzLlxuICAgIGZ1bmN0aW9uIGV4cGFuZElQdjYgKHN0cmluZywgcGFydHMpIHtcbiAgICAgICAgLy8gTW9yZSB0aGFuIG9uZSAnOjonIG1lYW5zIGludmFsaWQgYWRkZHJlc3NcbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCc6OicpICE9PSBzdHJpbmcubGFzdEluZGV4T2YoJzo6JykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbG9uQ291bnQgPSAwO1xuICAgICAgICBsZXQgbGFzdENvbG9uID0gLTE7XG4gICAgICAgIGxldCB6b25lSWQgPSAoc3RyaW5nLm1hdGNoKGlwdjZSZWdleGVzLnpvbmVJbmRleCkgfHwgW10pWzBdO1xuICAgICAgICBsZXQgcmVwbGFjZW1lbnQsIHJlcGxhY2VtZW50Q291bnQ7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHpvbmUgaW5kZXggYW5kIHNhdmUgaXQgZm9yIGxhdGVyXG4gICAgICAgIGlmICh6b25lSWQpIHtcbiAgICAgICAgICAgIHpvbmVJZCA9IHpvbmVJZC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvJS4rJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhvdyBtYW55IHBhcnRzIGRvIHdlIGFscmVhZHkgaGF2ZT9cbiAgICAgICAgd2hpbGUgKChsYXN0Q29sb24gPSBzdHJpbmcuaW5kZXhPZignOicsIGxhc3RDb2xvbiArIDEpKSA+PSAwKSB7XG4gICAgICAgICAgICBjb2xvbkNvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAwOjowIGlzIHR3byBwYXJ0cyBtb3JlIHRoYW4gOjpcbiAgICAgICAgaWYgKHN0cmluZy5zdWJzdHIoMCwgMikgPT09ICc6OicpIHtcbiAgICAgICAgICAgIGNvbG9uQ291bnQtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpbmcuc3Vic3RyKC0yLCAyKSA9PT0gJzo6Jykge1xuICAgICAgICAgICAgY29sb25Db3VudC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBsb29wIHdvdWxkIGhhbmcgaWYgY29sb25Db3VudCA+IHBhcnRzXG4gICAgICAgIGlmIChjb2xvbkNvdW50ID4gcGFydHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjZW1lbnQgPSAnOicgKyAnMDonICogKHBhcnRzIC0gY29sb25Db3VudClcbiAgICAgICAgcmVwbGFjZW1lbnRDb3VudCA9IHBhcnRzIC0gY29sb25Db3VudDtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSAnOic7XG4gICAgICAgIHdoaWxlIChyZXBsYWNlbWVudENvdW50LS0pIHtcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ICs9ICcwOic7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnNlcnQgdGhlIG1pc3NpbmcgemVyb2VzXG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKCc6OicsIHJlcGxhY2VtZW50KTtcblxuICAgICAgICAvLyBUcmltIGFueSBnYXJiYWdlIHdoaWNoIG1heSBiZSBoYW5naW5nIGFyb3VuZCBpZiA6OiB3YXMgYXQgdGhlIGVkZ2UgaW5cbiAgICAgICAgLy8gdGhlIHNvdXJjZSBzdHJpblxuICAgICAgICBpZiAoc3RyaW5nWzBdID09PSAnOicpIHtcbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSgxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpbmdbc3RyaW5nLmxlbmd0aCAtIDFdID09PSAnOicpIHtcbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSBzdHJpbmcuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocGFyc2VJbnQocmVmW2ldLCAxNikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSkoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFydHM6IHBhcnRzLFxuICAgICAgICAgICAgem9uZUlkOiB6b25lSWRcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBBIGdlbmVyaWMgQ0lEUiAoQ2xhc3NsZXNzIEludGVyLURvbWFpbiBSb3V0aW5nKSBSRkMxNTE4IHJhbmdlIG1hdGNoZXIuXG4gICAgZnVuY3Rpb24gbWF0Y2hDSURSIChmaXJzdCwgc2Vjb25kLCBwYXJ0U2l6ZSwgY2lkckJpdHMpIHtcbiAgICAgICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IGNhbm5vdCBtYXRjaCBDSURSIGZvciBvYmplY3RzIHdpdGggZGlmZmVyZW50IGxlbmd0aHMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwYXJ0ID0gMDtcbiAgICAgICAgbGV0IHNoaWZ0O1xuXG4gICAgICAgIHdoaWxlIChjaWRyQml0cyA+IDApIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gcGFydFNpemUgLSBjaWRyQml0cztcbiAgICAgICAgICAgIGlmIChzaGlmdCA8IDApIHtcbiAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJzdFtwYXJ0XSA+PiBzaGlmdCAhPT0gc2Vjb25kW3BhcnRdID4+IHNoaWZ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaWRyQml0cyAtPSBwYXJ0U2l6ZTtcbiAgICAgICAgICAgIHBhcnQgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW50QXV0byAoc3RyaW5nKSB7XG4gICAgICAgIC8vIEhleGFkZWRpbWFsIGJhc2UgMTYgKDB4IylcbiAgICAgICAgaWYgKGhleFJlZ2V4LnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgMTYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoaWxlIG9jdGFsIHJlcHJlc2VudGF0aW9uIGlzIGRpc2NvdXJhZ2VkIGJ5IEVDTUFTY3JpcHQgM1xuICAgICAgICAvLyBhbmQgZm9yYmlkZGVuIGJ5IEVDTUFTY3JpcHQgNSwgd2Ugc2lsZW50bHkgYWxsb3cgaXQgdG9cbiAgICAgICAgLy8gd29yayBvbmx5IGlmIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgaGFzIG51bWJlcnMgbGVzcyB0aGFuIDguXG4gICAgICAgIGlmIChzdHJpbmdbMF0gPT09ICcwJyAmJiAhaXNOYU4ocGFyc2VJbnQoc3RyaW5nWzFdLCAxMCkpKSB7XG4gICAgICAgIGlmIChvY3RhbFJlZ2V4LnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgOCk7XG4gICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaXBhZGRyOiBjYW5ub3QgcGFyc2UgJHtzdHJpbmd9IGFzIG9jdGFsYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWx3YXlzIGluY2x1ZGUgdGhlIGJhc2UgMTAgcmFkaXghXG4gICAgICAgIHJldHVybiBwYXJzZUludChzdHJpbmcsIDEwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWRQYXJ0IChwYXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKHBhcnQubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJ0ID0gYDAke3BhcnR9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgIH1cblxuICAgIGNvbnN0IGlwYWRkciA9IHt9O1xuXG4gICAgLy8gQW4gSVB2NCBhZGRyZXNzIChSRkM3OTEpLlxuICAgIGlwYWRkci5JUHY0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ29uc3RydWN0cyBhIG5ldyBJUHY0IGFkZHJlc3MgZnJvbSBhbiBhcnJheSBvZiBmb3VyIG9jdGV0c1xuICAgICAgICAvLyBpbiBuZXR3b3JrIG9yZGVyIChNU0IgZmlyc3QpXG4gICAgICAgIC8vIFZlcmlmaWVzIHRoZSBpbnB1dC5cbiAgICAgICAgZnVuY3Rpb24gSVB2NCAob2N0ZXRzKSB7XG4gICAgICAgICAgICBpZiAob2N0ZXRzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBpcHY0IG9jdGV0IGNvdW50IHNob3VsZCBiZSA0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBpLCBvY3RldDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9jdGV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG9jdGV0ID0gb2N0ZXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmICghKCgwIDw9IG9jdGV0ICYmIG9jdGV0IDw9IDI1NSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBpcHY0IG9jdGV0IHNob3VsZCBmaXQgaW4gOCBiaXRzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9jdGV0cyA9IG9jdGV0cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNwZWNpYWwgSVB2NCBhZGRyZXNzIHJhbmdlcy5cbiAgICAgICAgLy8gU2VlIGFsc28gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmVzZXJ2ZWRfSVBfYWRkcmVzc2VzXG4gICAgICAgIElQdjQucHJvdG90eXBlLlNwZWNpYWxSYW5nZXMgPSB7XG4gICAgICAgICAgICB1bnNwZWNpZmllZDogW1tuZXcgSVB2NChbMCwgMCwgMCwgMF0pLCA4XV0sXG4gICAgICAgICAgICBicm9hZGNhc3Q6IFtbbmV3IElQdjQoWzI1NSwgMjU1LCAyNTUsIDI1NV0pLCAzMl1dLFxuICAgICAgICAgICAgLy8gUkZDMzE3MVxuICAgICAgICAgICAgbXVsdGljYXN0OiBbW25ldyBJUHY0KFsyMjQsIDAsIDAsIDBdKSwgNF1dLFxuICAgICAgICAgICAgLy8gUkZDMzkyN1xuICAgICAgICAgICAgbGlua0xvY2FsOiBbW25ldyBJUHY0KFsxNjksIDI1NCwgMCwgMF0pLCAxNl1dLFxuICAgICAgICAgICAgLy8gUkZDNTczNVxuICAgICAgICAgICAgbG9vcGJhY2s6IFtbbmV3IElQdjQoWzEyNywgMCwgMCwgMF0pLCA4XV0sXG4gICAgICAgICAgICAvLyBSRkM2NTk4XG4gICAgICAgICAgICBjYXJyaWVyR3JhZGVOYXQ6IFtbbmV3IElQdjQoWzEwMCwgNjQsIDAsIDBdKSwgMTBdXSxcbiAgICAgICAgICAgIC8vIFJGQzE5MThcbiAgICAgICAgICAgICdwcml2YXRlJzogW1xuICAgICAgICAgICAgICAgIFtuZXcgSVB2NChbMTAsIDAsIDAsIDBdKSwgOF0sXG4gICAgICAgICAgICAgICAgW25ldyBJUHY0KFsxNzIsIDE2LCAwLCAwXSksIDEyXSxcbiAgICAgICAgICAgICAgICBbbmV3IElQdjQoWzE5MiwgMTY4LCAwLCAwXSksIDE2XVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8vIFJlc2VydmVkIGFuZCB0ZXN0aW5nLW9ubHkgcmFuZ2VzOyBSRkNzIDU3MzUsIDU3MzcsIDI1NDQsIDE3MDBcbiAgICAgICAgICAgIHJlc2VydmVkOiBbXG4gICAgICAgICAgICAgICAgW25ldyBJUHY0KFsxOTIsIDAsIDAsIDBdKSwgMjRdLFxuICAgICAgICAgICAgICAgIFtuZXcgSVB2NChbMTkyLCAwLCAyLCAwXSksIDI0XSxcbiAgICAgICAgICAgICAgICBbbmV3IElQdjQoWzE5MiwgODgsIDk5LCAwXSksIDI0XSxcbiAgICAgICAgICAgICAgICBbbmV3IElQdjQoWzE5OCwgMTgsIDAsIDBdKSwgMTVdLFxuICAgICAgICAgICAgICAgIFtuZXcgSVB2NChbMTk4LCA1MSwgMTAwLCAwXSksIDI0XSxcbiAgICAgICAgICAgICAgICBbbmV3IElQdjQoWzIwMywgMCwgMTEzLCAwXSksIDI0XSxcbiAgICAgICAgICAgICAgICBbbmV3IElQdjQoWzI0MCwgMCwgMCwgMF0pLCA0XVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIC8vIFJGQzc1MzQsIFJGQzc1MzVcbiAgICAgICAgICAgIGFzMTEyOiBbXG4gICAgICAgICAgICAgICAgW25ldyBJUHY0KFsxOTIsIDE3NSwgNDgsIDBdKSwgMjRdLFxuICAgICAgICAgICAgICAgIFtuZXcgSVB2NChbMTkyLCAzMSwgMTk2LCAwXSksIDI0XSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAvLyBSRkM3NDUwXG4gICAgICAgICAgICBhbXQ6IFtcbiAgICAgICAgICAgICAgICBbbmV3IElQdjQoWzE5MiwgNTIsIDE5MywgMF0pLCAyNF0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRoZSAna2luZCcgbWV0aG9kIGV4aXN0cyBvbiBib3RoIElQdjQgYW5kIElQdjYgY2xhc3Nlcy5cbiAgICAgICAgSVB2NC5wcm90b3R5cGUua2luZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnaXB2NCc7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoaXMgYWRkcmVzcyBtYXRjaGVzIG90aGVyIG9uZSB3aXRoaW4gZ2l2ZW4gQ0lEUiByYW5nZS5cbiAgICAgICAgSVB2NC5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAob3RoZXIsIGNpZHJSYW5nZSkge1xuICAgICAgICAgICAgbGV0IHJlZjtcbiAgICAgICAgICAgIGlmIChjaWRyUmFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlZiA9IG90aGVyO1xuICAgICAgICAgICAgICAgIG90aGVyID0gcmVmWzBdO1xuICAgICAgICAgICAgICAgIGNpZHJSYW5nZSA9IHJlZlsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG90aGVyLmtpbmQoKSAhPT0gJ2lwdjQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IGNhbm5vdCBtYXRjaCBpcHY0IGFkZHJlc3Mgd2l0aCBub24taXB2NCBvbmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoQ0lEUih0aGlzLm9jdGV0cywgb3RoZXIub2N0ZXRzLCA4LCBjaWRyUmFuZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgYSBudW1iZXIgb2YgbGVhZGluZyBvbmVzIGluIElQdjQgYWRkcmVzcywgbWFraW5nIHN1cmUgdGhhdFxuICAgICAgICAvLyB0aGUgcmVzdCBpcyBhIHNvbGlkIHNlcXVlbmNlIG9mIDAncyAodmFsaWQgbmV0bWFzaylcbiAgICAgICAgLy8gcmV0dXJucyBlaXRoZXIgdGhlIENJRFIgbGVuZ3RoIG9yIG51bGwgaWYgbWFzayBpcyBub3QgdmFsaWRcbiAgICAgICAgSVB2NC5wcm90b3R5cGUucHJlZml4TGVuZ3RoRnJvbVN1Ym5ldE1hc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgY2lkciA9IDA7XG4gICAgICAgICAgICAvLyBub24temVybyBlbmNvdW50ZXJlZCBzdG9wIHNjYW5uaW5nIGZvciB6ZXJvZXNcbiAgICAgICAgICAgIGxldCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBudW1iZXIgb2YgemVyb2VzIGluIG9jdGV0XG4gICAgICAgICAgICBjb25zdCB6ZXJvdGFibGUgPSB7XG4gICAgICAgICAgICAgICAgMDogOCxcbiAgICAgICAgICAgICAgICAxMjg6IDcsXG4gICAgICAgICAgICAgICAgMTkyOiA2LFxuICAgICAgICAgICAgICAgIDIyNDogNSxcbiAgICAgICAgICAgICAgICAyNDA6IDQsXG4gICAgICAgICAgICAgICAgMjQ4OiAzLFxuICAgICAgICAgICAgICAgIDI1MjogMixcbiAgICAgICAgICAgICAgICAyNTQ6IDEsXG4gICAgICAgICAgICAgICAgMjU1OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGksIG9jdGV0LCB6ZXJvcztcblxuICAgICAgICAgICAgZm9yIChpID0gMzsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICBvY3RldCA9IHRoaXMub2N0ZXRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvY3RldCBpbiB6ZXJvdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgemVyb3MgPSB6ZXJvdGFibGVbb2N0ZXRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcCAmJiB6ZXJvcyAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoemVyb3MgIT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2lkciArPSB6ZXJvcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAzMiAtIGNpZHI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGNvcnJlc3BvbmRzIHRvIG9uZSBvZiB0aGUgc3BlY2lhbCByYW5nZXMuXG4gICAgICAgIElQdjQucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlwYWRkci5zdWJuZXRNYXRjaCh0aGlzLCB0aGlzLlNwZWNpYWxSYW5nZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYnl0ZS1zaXplZCB2YWx1ZXMgaW4gbmV0d29yayBvcmRlciAoTVNCIGZpcnN0KVxuICAgICAgICBJUHY0LnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9jdGV0cy5zbGljZSgwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDb252ZXJ0cyB0aGlzIElQdjQgYWRkcmVzcyB0byBhbiBJUHY0LW1hcHBlZCBJUHY2IGFkZHJlc3MuXG4gICAgICAgIElQdjQucHJvdG90eXBlLnRvSVB2NE1hcHBlZEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXBhZGRyLklQdjYucGFyc2UoYDo6ZmZmZjoke3RoaXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTeW1tZXRyaWNhbCBtZXRob2Qgc3RyaWN0bHkgZm9yIGFsaWduaW5nIHdpdGggdGhlIElQdjYgbWV0aG9kcy5cbiAgICAgICAgSVB2NC5wcm90b3R5cGUudG9Ob3JtYWxpemVkU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBhZGRyZXNzIGluIGNvbnZlbmllbnQsIGRlY2ltYWwtZG90dGVkIGZvcm1hdC5cbiAgICAgICAgSVB2NC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vY3RldHMuam9pbignLicpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBJUHY0O1xuICAgIH0pKCk7XG5cbiAgICAvLyBBIHV0aWxpdHkgZnVuY3Rpb24gdG8gcmV0dXJuIGJyb2FkY2FzdCBhZGRyZXNzIGdpdmVuIHRoZSBJUHY0IGludGVyZmFjZSBhbmQgcHJlZml4IGxlbmd0aCBpbiBDSURSIG5vdGF0aW9uXG4gICAgaXBhZGRyLklQdjQuYnJvYWRjYXN0QWRkcmVzc0Zyb21DSURSID0gZnVuY3Rpb24gKHN0cmluZykge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjaWRyID0gdGhpcy5wYXJzZUNJRFIoc3RyaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IGlwSW50ZXJmYWNlT2N0ZXRzID0gY2lkclswXS50b0J5dGVBcnJheSgpO1xuICAgICAgICAgICAgY29uc3Qgc3VibmV0TWFza09jdGV0cyA9IHRoaXMuc3VibmV0TWFza0Zyb21QcmVmaXhMZW5ndGgoY2lkclsxXSkudG9CeXRlQXJyYXkoKTtcbiAgICAgICAgICAgIGNvbnN0IG9jdGV0cyA9IFtdO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCA0KSB7XG4gICAgICAgICAgICAgICAgLy8gQnJvYWRjYXN0IGFkZHJlc3MgaXMgYml0d2lzZSBPUiBiZXR3ZWVuIGlwIGludGVyZmFjZSBhbmQgaW52ZXJ0ZWQgbWFza1xuICAgICAgICAgICAgICAgIG9jdGV0cy5wdXNoKHBhcnNlSW50KGlwSW50ZXJmYWNlT2N0ZXRzW2ldLCAxMCkgfCBwYXJzZUludChzdWJuZXRNYXNrT2N0ZXRzW2ldLCAxMCkgXiAyNTUpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG9jdGV0cyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiB0aGUgYWRkcmVzcyBkb2VzIG5vdCBoYXZlIElQdjQgQ0lEUiBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDaGVja3MgaWYgYSBnaXZlbiBzdHJpbmcgaXMgZm9ybWF0dGVkIGxpa2UgSVB2NCBhZGRyZXNzLlxuICAgIGlwYWRkci5JUHY0LmlzSVB2NCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyKHN0cmluZykgIT09IG51bGw7XG4gICAgfTtcblxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIElQdjQgYWRkcmVzcy5cbiAgICBpcGFkZHIuSVB2NC5pc1ZhbGlkID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IHRoaXModGhpcy5wYXJzZXIoc3RyaW5nKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIENoZWNrcyBpZiBhIGdpdmVuIHN0cmluZyBpcyBhIHZhbGlkIElQdjQgYWRkcmVzcyBpbiBDSURSIG5vdGF0aW9uLlxuICAgIGlwYWRkci5JUHY0LmlzVmFsaWRDSURSID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5wYXJzZUNJRFIoc3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gc3RyaW5nIGlzIGEgZnVsbCBmb3VyLXBhcnQgSVB2NCBBZGRyZXNzLlxuICAgIGlwYWRkci5JUHY0LmlzVmFsaWRGb3VyUGFydERlY2ltYWwgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIGlmIChpcGFkZHIuSVB2NC5pc1ZhbGlkKHN0cmluZykgJiYgc3RyaW5nLm1hdGNoKC9eKDB8WzEtOV1cXGQqKShcXC4oMHxbMS05XVxcZCopKXszfSQvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIHJldHVybiBuZXR3b3JrIGFkZHJlc3MgZ2l2ZW4gdGhlIElQdjQgaW50ZXJmYWNlIGFuZCBwcmVmaXggbGVuZ3RoIGluIENJRFIgbm90YXRpb25cbiAgICBpcGFkZHIuSVB2NC5uZXR3b3JrQWRkcmVzc0Zyb21DSURSID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICBsZXQgY2lkciwgaSwgaXBJbnRlcmZhY2VPY3RldHMsIG9jdGV0cywgc3VibmV0TWFza09jdGV0cztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2lkciA9IHRoaXMucGFyc2VDSURSKHN0cmluZyk7XG4gICAgICAgICAgICBpcEludGVyZmFjZU9jdGV0cyA9IGNpZHJbMF0udG9CeXRlQXJyYXkoKTtcbiAgICAgICAgICAgIHN1Ym5ldE1hc2tPY3RldHMgPSB0aGlzLnN1Ym5ldE1hc2tGcm9tUHJlZml4TGVuZ3RoKGNpZHJbMV0pLnRvQnl0ZUFycmF5KCk7XG4gICAgICAgICAgICBvY3RldHMgPSBbXTtcbiAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCA0KSB7XG4gICAgICAgICAgICAgICAgLy8gTmV0d29yayBhZGRyZXNzIGlzIGJpdHdpc2UgQU5EIGJldHdlZW4gaXAgaW50ZXJmYWNlIGFuZCBtYXNrXG4gICAgICAgICAgICAgICAgb2N0ZXRzLnB1c2gocGFyc2VJbnQoaXBJbnRlcmZhY2VPY3RldHNbaV0sIDEwKSAmIHBhcnNlSW50KHN1Ym5ldE1hc2tPY3RldHNbaV0sIDEwKSk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMob2N0ZXRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IHRoZSBhZGRyZXNzIGRvZXMgbm90IGhhdmUgSVB2NCBDSURSIGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRyaWVzIHRvIHBhcnNlIGFuZCB2YWxpZGF0ZSBhIHN0cmluZyB3aXRoIElQdjQgYWRkcmVzcy5cbiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXG4gICAgaXBhZGRyLklQdjQucGFyc2UgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gdGhpcy5wYXJzZXIoc3RyaW5nKTtcblxuICAgICAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBzdHJpbmcgaXMgbm90IGZvcm1hdHRlZCBsaWtlIGFuIElQdjQgQWRkcmVzcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHBhcnRzKTtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIHRoZSBzdHJpbmcgYXMgYW4gSVB2NCBBZGRyZXNzIHdpdGggQ0lEUiBOb3RhdGlvbi5cbiAgICBpcGFkZHIuSVB2NC5wYXJzZUNJRFIgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIGxldCBtYXRjaDtcblxuICAgICAgICBpZiAoKG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eKC4rKVxcLyhcXGQrKSQvKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hc2tMZW5ndGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgICAgICBpZiAobWFza0xlbmd0aCA+PSAwICYmIG1hc2tMZW5ndGggPD0gMzIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBbdGhpcy5wYXJzZShtYXRjaFsxXSksIG1hc2tMZW5ndGhdO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJzZWQsICd0b1N0cmluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgbGlrZSBhbiBJUHY0IENJRFIgcmFuZ2UnKTtcbiAgICB9O1xuXG4gICAgLy8gQ2xhc3NmdWwgdmFyaWFudHMgKGxpa2UgYS5iLCB3aGVyZSBhIGlzIGFuIG9jdGV0LCBhbmQgYiBpcyBhIDI0LWJpdFxuICAgIC8vIHZhbHVlIHJlcHJlc2VudGluZyBsYXN0IHRocmVlIG9jdGV0czsgdGhpcyBjb3JyZXNwb25kcyB0byBhIGNsYXNzIENcbiAgICAvLyBhZGRyZXNzKSBhcmUgb21pdHRlZCBkdWUgdG8gY2xhc3NsZXNzIG5hdHVyZSBvZiBtb2Rlcm4gSW50ZXJuZXQuXG4gICAgaXBhZGRyLklQdjQucGFyc2VyID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICBsZXQgbWF0Y2gsIHBhcnQsIHZhbHVlO1xuXG4gICAgICAgIC8vIHBhcnNlSW50IHJlY29nbml6ZXMgYWxsIHRoYXQgb2N0YWwgJiBoZXhhZGVjaW1hbCB3ZWlyZG5lc3MgZm9yIHVzXG4gICAgICAgIGlmICgobWF0Y2ggPSBzdHJpbmcubWF0Y2goaXB2NFJlZ2V4ZXMuZm91ck9jdGV0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IG1hdGNoLnNsaWNlKDEsIDYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSByZWZbaV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwYXJzZUludEF1dG8ocGFydCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBzdHJpbmcubWF0Y2goaXB2NFJlZ2V4ZXMubG9uZ1ZhbHVlKSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnRBdXRvKG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IDB4ZmZmZmZmZmYgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IGFkZHJlc3Mgb3V0c2lkZSBkZWZpbmVkIHJhbmdlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IHNoaWZ0O1xuXG4gICAgICAgICAgICAgICAgZm9yIChzaGlmdCA9IDA7IHNoaWZ0IDw9IDI0OyBzaGlmdCArPSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCgodmFsdWUgPj4gc2hpZnQpICYgMHhmZik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpKS5yZXZlcnNlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjRSZWdleGVzLnR3b09jdGV0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IG1hdGNoLnNsaWNlKDEsIDQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnRBdXRvKHJlZlsxXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gMHhmZmZmZmYgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBhZGRyZXNzIG91dHNpZGUgZGVmaW5lZCByYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwYXJzZUludEF1dG8ocmVmWzBdKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCh2YWx1ZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goKHZhbHVlID4+ICA4KSAmIDB4ZmYpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggdmFsdWUgICAgICAgICYgMHhmZik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjRSZWdleGVzLnRocmVlT2N0ZXQpKSkge1xuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gbWF0Y2guc2xpY2UoMSwgNSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludEF1dG8ocmVmWzJdKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAweGZmZmYgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBhZGRyZXNzIG91dHNpZGUgZGVmaW5lZCByYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChwYXJzZUludEF1dG8ocmVmWzBdKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHBhcnNlSW50QXV0byhyZWZbMV0pKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goKHZhbHVlID4+IDgpICYgMHhmZik7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKCB2YWx1ZSAgICAgICAmIDB4ZmYpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIHJldHVybiBzdWJuZXQgbWFzayBpbiBJUHY0IGZvcm1hdCBnaXZlbiB0aGUgcHJlZml4IGxlbmd0aFxuICAgIGlwYWRkci5JUHY0LnN1Ym5ldE1hc2tGcm9tUHJlZml4TGVuZ3RoID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICBwcmVmaXggPSBwYXJzZUludChwcmVmaXgpO1xuICAgICAgICBpZiAocHJlZml4IDwgMCB8fCBwcmVmaXggPiAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IGludmFsaWQgSVB2NCBwcmVmaXggbGVuZ3RoJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvY3RldHMgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgY29uc3QgZmlsbGVkT2N0ZXRDb3VudCA9IE1hdGguZmxvb3IocHJlZml4IC8gOCk7XG5cbiAgICAgICAgd2hpbGUgKGogPCBmaWxsZWRPY3RldENvdW50KSB7XG4gICAgICAgICAgICBvY3RldHNbal0gPSAyNTU7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbGVkT2N0ZXRDb3VudCA8IDQpIHtcbiAgICAgICAgICAgIG9jdGV0c1tmaWxsZWRPY3RldENvdW50XSA9IE1hdGgucG93KDIsIHByZWZpeCAlIDgpIC0gMSA8PCA4IC0gKHByZWZpeCAlIDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG9jdGV0cyk7XG4gICAgfTtcblxuICAgIC8vIEFuIElQdjYgYWRkcmVzcyAoUkZDMjQ2MClcbiAgICBpcGFkZHIuSVB2NiA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdHMgYW4gSVB2NiBhZGRyZXNzIGZyb20gYW4gYXJyYXkgb2YgZWlnaHQgMTYgLSBiaXQgcGFydHNcbiAgICAgICAgLy8gb3Igc2l4dGVlbiA4IC0gYml0IHBhcnRzIGluIG5ldHdvcmsgb3JkZXIoTVNCIGZpcnN0KS5cbiAgICAgICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBpbnB1dCBpcyBpbnZhbGlkLlxuICAgICAgICBmdW5jdGlvbiBJUHY2IChwYXJ0cywgem9uZUlkKSB7XG4gICAgICAgICAgICBsZXQgaSwgcGFydDtcblxuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8PSAxNDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaCgocGFydHNbaV0gPDwgOCkgfCBwYXJ0c1tpICsgMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFydHMubGVuZ3RoID09PSA4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0cyA9IHBhcnRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogaXB2NiBwYXJ0IGNvdW50IHNob3VsZCBiZSA4IG9yIDE2Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFydCA9IHRoaXMucGFydHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCEoKDAgPD0gcGFydCAmJiBwYXJ0IDw9IDB4ZmZmZikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBpcHY2IHBhcnQgc2hvdWxkIGZpdCBpbiAxNiBiaXRzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoem9uZUlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy56b25lSWQgPSB6b25lSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTcGVjaWFsIElQdjYgcmFuZ2VzXG4gICAgICAgIElQdjYucHJvdG90eXBlLlNwZWNpYWxSYW5nZXMgPSB7XG4gICAgICAgICAgICAvLyBSRkM0MjkxLCBoZXJlIGFuZCBhZnRlclxuICAgICAgICAgICAgdW5zcGVjaWZpZWQ6IFtuZXcgSVB2NihbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAxMjhdLFxuICAgICAgICAgICAgbGlua0xvY2FsOiBbbmV3IElQdjYoWzB4ZmU4MCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCAxMF0sXG4gICAgICAgICAgICBtdWx0aWNhc3Q6IFtuZXcgSVB2NihbMHhmZjAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDhdLFxuICAgICAgICAgICAgbG9vcGJhY2s6IFtuZXcgSVB2NihbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMV0pLCAxMjhdLFxuICAgICAgICAgICAgdW5pcXVlTG9jYWw6IFtuZXcgSVB2NihbMHhmYzAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDddLFxuICAgICAgICAgICAgaXB2NE1hcHBlZDogW25ldyBJUHY2KFswLCAwLCAwLCAwLCAwLCAweGZmZmYsIDAsIDBdKSwgOTZdLFxuICAgICAgICAgICAgLy8gUkZDNjY2NlxuICAgICAgICAgICAgZGlzY2FyZDogW25ldyBJUHY2KFsweDEwMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pLCA2NF0sXG4gICAgICAgICAgICAvLyBSRkM2MTQ1XG4gICAgICAgICAgICByZmM2MTQ1OiBbbmV3IElQdjYoWzAsIDAsIDAsIDAsIDB4ZmZmZiwgMCwgMCwgMF0pLCA5Nl0sXG4gICAgICAgICAgICAvLyBSRkM2MDUyXG4gICAgICAgICAgICByZmM2MDUyOiBbbmV3IElQdjYoWzB4NjQsIDB4ZmY5YiwgMCwgMCwgMCwgMCwgMCwgMF0pLCA5Nl0sXG4gICAgICAgICAgICAvLyBSRkMzMDU2XG4gICAgICAgICAgICAnNnRvNCc6IFtuZXcgSVB2NihbMHgyMDAyLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDE2XSxcbiAgICAgICAgICAgIC8vIFJGQzYwNTIsIFJGQzYxNDZcbiAgICAgICAgICAgIHRlcmVkbzogW25ldyBJUHY2KFsweDIwMDEsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKSwgMzJdLFxuICAgICAgICAgICAgLy8gUkZDNTE4MFxuICAgICAgICAgICAgYmVuY2htYXJraW5nOiBbbmV3IElQdjYoWzB4MjAwMSwgMHgyLCAwLCAwLCAwLCAwLCAwLCAwXSksIDQ4XSxcbiAgICAgICAgICAgIC8vIFJGQzc0NTBcbiAgICAgICAgICAgIGFtdDogW25ldyBJUHY2KFsweDIwMDEsIDB4MywgMCwgMCwgMCwgMCwgMCwgMF0pLCAzMl0sXG4gICAgICAgICAgICBhczExMnY2OiBbXG4gICAgICAgICAgICAgICAgW25ldyBJUHY2KFsweDIwMDEsIDB4NCwgMHgxMTIsIDAsIDAsIDAsIDAsIDBdKSwgNDhdLFxuICAgICAgICAgICAgICAgIFtuZXcgSVB2NihbMHgyNjIwLCAweDRmLCAweDgwMDAsIDAsIDAsIDAsIDAsIDBdKSwgNDhdLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRlcHJlY2F0ZWQ6IFtuZXcgSVB2NihbMHgyMDAxLCAweDEwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDI4XSxcbiAgICAgICAgICAgIG9yY2hpZDI6IFtuZXcgSVB2NihbMHgyMDAxLCAweDIwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDI4XSxcbiAgICAgICAgICAgIGRyb25lUmVtb3RlSWRQcm90b2NvbEVudGl0eVRhZ3M6IFtuZXcgSVB2NihbMHgyMDAxLCAweDMwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDI4XSxcbiAgICAgICAgICAgIHJlc2VydmVkOiBbXG4gICAgICAgICAgICAgICAgLy8gUkZDMzg0OVxuICAgICAgICAgICAgICAgIFtuZXcgSVB2NihbMHgyMDAxLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSksIDIzXSxcbiAgICAgICAgICAgICAgICAvLyBSRkMyOTI4XG4gICAgICAgICAgICAgICAgW25ldyBJUHY2KFsweDIwMDEsIDB4ZGI4LCAwLCAwLCAwLCAwLCAwLCAwXSksIDMyXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoaXMgYWRkcmVzcyBpcyBhbiBJUHY0LW1hcHBlZCBJUHY2IGFkZHJlc3MuXG4gICAgICAgIElQdjYucHJvdG90eXBlLmlzSVB2NE1hcHBlZEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5nZSgpID09PSAnaXB2NE1hcHBlZCc7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVGhlICdraW5kJyBtZXRob2QgZXhpc3RzIG9uIGJvdGggSVB2NCBhbmQgSVB2NiBjbGFzc2VzLlxuICAgICAgICBJUHY2LnByb3RvdHlwZS5raW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdpcHY2JztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhpcyBhZGRyZXNzIG1hdGNoZXMgb3RoZXIgb25lIHdpdGhpbiBnaXZlbiBDSURSIHJhbmdlLlxuICAgICAgICBJUHY2LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChvdGhlciwgY2lkclJhbmdlKSB7XG4gICAgICAgICAgICBsZXQgcmVmO1xuXG4gICAgICAgICAgICBpZiAoY2lkclJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZWYgPSBvdGhlcjtcbiAgICAgICAgICAgICAgICBvdGhlciA9IHJlZlswXTtcbiAgICAgICAgICAgICAgICBjaWRyUmFuZ2UgPSByZWZbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvdGhlci5raW5kKCkgIT09ICdpcHY2Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBjYW5ub3QgbWF0Y2ggaXB2NiBhZGRyZXNzIHdpdGggbm9uLWlwdjYgb25lJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaENJRFIodGhpcy5wYXJ0cywgb3RoZXIucGFydHMsIDE2LCBjaWRyUmFuZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHJldHVybnMgYSBudW1iZXIgb2YgbGVhZGluZyBvbmVzIGluIElQdjYgYWRkcmVzcywgbWFraW5nIHN1cmUgdGhhdFxuICAgICAgICAvLyB0aGUgcmVzdCBpcyBhIHNvbGlkIHNlcXVlbmNlIG9mIDAncyAodmFsaWQgbmV0bWFzaylcbiAgICAgICAgLy8gcmV0dXJucyBlaXRoZXIgdGhlIENJRFIgbGVuZ3RoIG9yIG51bGwgaWYgbWFzayBpcyBub3QgdmFsaWRcbiAgICAgICAgSVB2Ni5wcm90b3R5cGUucHJlZml4TGVuZ3RoRnJvbVN1Ym5ldE1hc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZXQgY2lkciA9IDA7XG4gICAgICAgICAgICAvLyBub24temVybyBlbmNvdW50ZXJlZCBzdG9wIHNjYW5uaW5nIGZvciB6ZXJvZXNcbiAgICAgICAgICAgIGxldCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBudW1iZXIgb2YgemVyb2VzIGluIG9jdGV0XG4gICAgICAgICAgICBjb25zdCB6ZXJvdGFibGUgPSB7XG4gICAgICAgICAgICAgICAgMDogMTYsXG4gICAgICAgICAgICAgICAgMzI3Njg6IDE1LFxuICAgICAgICAgICAgICAgIDQ5MTUyOiAxNCxcbiAgICAgICAgICAgICAgICA1NzM0NDogMTMsXG4gICAgICAgICAgICAgICAgNjE0NDA6IDEyLFxuICAgICAgICAgICAgICAgIDYzNDg4OiAxMSxcbiAgICAgICAgICAgICAgICA2NDUxMjogMTAsXG4gICAgICAgICAgICAgICAgNjUwMjQ6IDksXG4gICAgICAgICAgICAgICAgNjUyODA6IDgsXG4gICAgICAgICAgICAgICAgNjU0MDg6IDcsXG4gICAgICAgICAgICAgICAgNjU0NzI6IDYsXG4gICAgICAgICAgICAgICAgNjU1MDQ6IDUsXG4gICAgICAgICAgICAgICAgNjU1MjA6IDQsXG4gICAgICAgICAgICAgICAgNjU1Mjg6IDMsXG4gICAgICAgICAgICAgICAgNjU1MzI6IDIsXG4gICAgICAgICAgICAgICAgNjU1MzQ6IDEsXG4gICAgICAgICAgICAgICAgNjU1MzU6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcGFydCwgemVyb3M7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSA3OyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgIHBhcnQgPSB0aGlzLnBhcnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0IGluIHplcm90YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB6ZXJvcyA9IHplcm90YWJsZVtwYXJ0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3AgJiYgemVyb3MgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHplcm9zICE9PSAxNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaWRyICs9IHplcm9zO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDEyOCAtIGNpZHI7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGFkZHJlc3MgY29ycmVzcG9uZHMgdG8gb25lIG9mIHRoZSBzcGVjaWFsIHJhbmdlcy5cbiAgICAgICAgSVB2Ni5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXBhZGRyLnN1Ym5ldE1hdGNoKHRoaXMsIHRoaXMuU3BlY2lhbFJhbmdlcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyBhbiBhcnJheSBvZiBieXRlLXNpemVkIHZhbHVlcyBpbiBuZXR3b3JrIG9yZGVyIChNU0IgZmlyc3QpXG4gICAgICAgIElQdjYucHJvdG90eXBlLnRvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGV0IHBhcnQ7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5wYXJ0cztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFydCA9IHJlZltpXTtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKHBhcnQgPj4gOCk7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChwYXJ0ICYgMHhmZik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBhZGRyZXNzIGluIGV4cGFuZGVkIGZvcm1hdCB3aXRoIGFsbCB6ZXJvZXMgaW5jbHVkZWQsIGxpa2VcbiAgICAgICAgLy8gMjAwMTowZGI4OjAwMDg6MDA2NjowMDAwOjAwMDA6MDAwMDowMDAxXG4gICAgICAgIElQdjYucHJvdG90eXBlLnRvRml4ZWRMZW5ndGhTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gKChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocGFkUGFydCh0aGlzLnBhcnRzW2ldLnRvU3RyaW5nKDE2KSwgNCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKSkuam9pbignOicpO1xuXG4gICAgICAgICAgICBsZXQgc3VmZml4ID0gJyc7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnpvbmVJZCkge1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IGAlJHt0aGlzLnpvbmVJZH1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkciArIHN1ZmZpeDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDb252ZXJ0cyB0aGlzIGFkZHJlc3MgdG8gSVB2NCBhZGRyZXNzIGlmIGl0IGlzIGFuIElQdjQtbWFwcGVkIElQdjYgYWRkcmVzcy5cbiAgICAgICAgLy8gVGhyb3dzIGFuIGVycm9yIG90aGVyd2lzZS5cbiAgICAgICAgSVB2Ni5wcm90b3R5cGUudG9JUHY0QWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0lQdjRNYXBwZWRBZGRyZXNzKCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogdHJ5aW5nIHRvIGNvbnZlcnQgYSBnZW5lcmljIGlwdjYgYWRkcmVzcyB0byBpcHY0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMucGFydHMuc2xpY2UoLTIpO1xuICAgICAgICAgICAgY29uc3QgaGlnaCA9IHJlZlswXTtcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IHJlZlsxXTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBpcGFkZHIuSVB2NChbaGlnaCA+PiA4LCBoaWdoICYgMHhmZiwgbG93ID4+IDgsIGxvdyAmIDB4ZmZdKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBhZGRyZXNzIGluIGV4cGFuZGVkIGZvcm1hdCB3aXRoIGFsbCB6ZXJvZXMgaW5jbHVkZWQsIGxpa2VcbiAgICAgICAgLy8gMjAwMTpkYjg6ODo2NjowOjA6MDoxXG4gICAgICAgIC8vXG4gICAgICAgIC8vIERlcHJlY2F0ZWQ6IHVzZSB0b0ZpeGVkTGVuZ3RoU3RyaW5nKCkgaW5zdGVhZC5cbiAgICAgICAgSVB2Ni5wcm90b3R5cGUudG9Ob3JtYWxpemVkU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgYWRkciA9ICgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5wYXJ0c1tpXS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSkuY2FsbCh0aGlzKSkuam9pbignOicpO1xuXG4gICAgICAgICAgICBsZXQgc3VmZml4ID0gJyc7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnpvbmVJZCkge1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IGAlJHt0aGlzLnpvbmVJZH1gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWRkciArIHN1ZmZpeDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBhZGRyZXNzIGluIGNvbXBhY3QsIGh1bWFuLXJlYWRhYmxlIGZvcm1hdCBsaWtlXG4gICAgICAgIC8vIDIwMDE6ZGI4Ojg6NjY6OjFcbiAgICAgICAgLy8gaW4gbGluZSB3aXRoIFJGQyA1OTUyIChzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzU5NTIjc2VjdGlvbi00KVxuICAgICAgICBJUHY2LnByb3RvdHlwZS50b1JGQzU5NTJTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWdleCA9IC8oKF58OikoMCg6fCQpKXsyLH0pL2c7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmcgPSB0aGlzLnRvTm9ybWFsaXplZFN0cmluZygpO1xuICAgICAgICAgICAgbGV0IGJlc3RNYXRjaEluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBiZXN0TWF0Y2hMZW5ndGggPSAtMTtcbiAgICAgICAgICAgIGxldCBtYXRjaDtcblxuICAgICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyaW5nKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMF0ubGVuZ3RoID4gYmVzdE1hdGNoTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChiZXN0TWF0Y2hMZW5ndGggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGAke3N0cmluZy5zdWJzdHJpbmcoMCwgYmVzdE1hdGNoSW5kZXgpfTo6JHtzdHJpbmcuc3Vic3RyaW5nKGJlc3RNYXRjaEluZGV4ICsgYmVzdE1hdGNoTGVuZ3RoKX1gO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGFkZHJlc3MgaW4gY29tcGFjdCwgaHVtYW4tcmVhZGFibGUgZm9ybWF0IGxpa2VcbiAgICAgICAgLy8gMjAwMTpkYjg6ODo2Njo6MVxuICAgICAgICAvLyBDYWxscyB0b1JGQzU5NTJTdHJpbmcgdW5kZXIgdGhlIGhvb2QuXG4gICAgICAgIElQdjYucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9SRkM1OTUyU3RyaW5nKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIElQdjY7XG5cbiAgICB9KSgpO1xuXG4gICAgLy8gQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIHJldHVybiBicm9hZGNhc3QgYWRkcmVzcyBnaXZlbiB0aGUgSVB2NiBpbnRlcmZhY2UgYW5kIHByZWZpeCBsZW5ndGggaW4gQ0lEUiBub3RhdGlvblxuICAgIGlwYWRkci5JUHY2LmJyb2FkY2FzdEFkZHJlc3NGcm9tQ0lEUiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNpZHIgPSB0aGlzLnBhcnNlQ0lEUihzdHJpbmcpO1xuICAgICAgICAgICAgY29uc3QgaXBJbnRlcmZhY2VPY3RldHMgPSBjaWRyWzBdLnRvQnl0ZUFycmF5KCk7XG4gICAgICAgICAgICBjb25zdCBzdWJuZXRNYXNrT2N0ZXRzID0gdGhpcy5zdWJuZXRNYXNrRnJvbVByZWZpeExlbmd0aChjaWRyWzFdKS50b0J5dGVBcnJheSgpO1xuICAgICAgICAgICAgY29uc3Qgb2N0ZXRzID0gW107XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgLy8gQnJvYWRjYXN0IGFkZHJlc3MgaXMgYml0d2lzZSBPUiBiZXR3ZWVuIGlwIGludGVyZmFjZSBhbmQgaW52ZXJ0ZWQgbWFza1xuICAgICAgICAgICAgICAgIG9jdGV0cy5wdXNoKHBhcnNlSW50KGlwSW50ZXJmYWNlT2N0ZXRzW2ldLCAxMCkgfCBwYXJzZUludChzdWJuZXRNYXNrT2N0ZXRzW2ldLCAxMCkgXiAyNTUpO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG9jdGV0cyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaXBhZGRyOiB0aGUgYWRkcmVzcyBkb2VzIG5vdCBoYXZlIElQdjYgQ0lEUiBmb3JtYXQgKCR7ZX0pYCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gc3RyaW5nIGlzIGZvcm1hdHRlZCBsaWtlIElQdjYgYWRkcmVzcy5cbiAgICBpcGFkZHIuSVB2Ni5pc0lQdjYgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlcihzdHJpbmcpICE9PSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBDaGVja3MgdG8gc2VlIGlmIHN0cmluZyBpcyBhIHZhbGlkIElQdjYgQWRkcmVzc1xuICAgIGlwYWRkci5JUHY2LmlzVmFsaWQgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICAgICAgLy8gU2luY2UgSVB2Ni5pc1ZhbGlkIGlzIGFsd2F5cyBjYWxsZWQgZmlyc3QsIHRoaXMgc2hvcnRjdXRcbiAgICAgICAgLy8gcHJvdmlkZXMgYSBzdWJzdGFudGlhbCBwZXJmb3JtYW5jZSBnYWluLlxuICAgICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycgJiYgc3RyaW5nLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0gdGhpcy5wYXJzZXIoc3RyaW5nKTtcbiAgICAgICAgICAgIG5ldyB0aGlzKGFkZHIucGFydHMsIGFkZHIuem9uZUlkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gc3RyaW5nIGlzIGEgdmFsaWQgSVB2NiBhZGRyZXNzIGluIENJRFIgbm90YXRpb24uXG4gICAgaXBhZGRyLklQdjYuaXNWYWxpZENJRFIgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cbiAgICAgICAgLy8gU2VlIG5vdGUgaW4gSVB2Ni5pc1ZhbGlkXG4gICAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyAmJiBzdHJpbmcuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VDSURSKHN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEEgdXRpbGl0eSBmdW5jdGlvbiB0byByZXR1cm4gbmV0d29yayBhZGRyZXNzIGdpdmVuIHRoZSBJUHY2IGludGVyZmFjZSBhbmQgcHJlZml4IGxlbmd0aCBpbiBDSURSIG5vdGF0aW9uXG4gICAgaXBhZGRyLklQdjYubmV0d29ya0FkZHJlc3NGcm9tQ0lEUiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgbGV0IGNpZHIsIGksIGlwSW50ZXJmYWNlT2N0ZXRzLCBvY3RldHMsIHN1Ym5ldE1hc2tPY3RldHM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNpZHIgPSB0aGlzLnBhcnNlQ0lEUihzdHJpbmcpO1xuICAgICAgICAgICAgaXBJbnRlcmZhY2VPY3RldHMgPSBjaWRyWzBdLnRvQnl0ZUFycmF5KCk7XG4gICAgICAgICAgICBzdWJuZXRNYXNrT2N0ZXRzID0gdGhpcy5zdWJuZXRNYXNrRnJvbVByZWZpeExlbmd0aChjaWRyWzFdKS50b0J5dGVBcnJheSgpO1xuICAgICAgICAgICAgb2N0ZXRzID0gW107XG4gICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGFkZHJlc3MgaXMgYml0d2lzZSBBTkQgYmV0d2VlbiBpcCBpbnRlcmZhY2UgYW5kIG1hc2tcbiAgICAgICAgICAgICAgICBvY3RldHMucHVzaChwYXJzZUludChpcEludGVyZmFjZU9jdGV0c1tpXSwgMTApICYgcGFyc2VJbnQoc3VibmV0TWFza09jdGV0c1tpXSwgMTApKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcyhvY3RldHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlwYWRkcjogdGhlIGFkZHJlc3MgZG9lcyBub3QgaGF2ZSBJUHY2IENJRFIgZm9ybWF0ICgke2V9KWApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRyaWVzIHRvIHBhcnNlIGFuZCB2YWxpZGF0ZSBhIHN0cmluZyB3aXRoIElQdjYgYWRkcmVzcy5cbiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgZmFpbHMuXG4gICAgaXBhZGRyLklQdjYucGFyc2UgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGFkZHIgPSB0aGlzLnBhcnNlcihzdHJpbmcpO1xuXG4gICAgICAgIGlmIChhZGRyLnBhcnRzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogc3RyaW5nIGlzIG5vdCBmb3JtYXR0ZWQgbGlrZSBhbiBJUHY2IEFkZHJlc3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhhZGRyLnBhcnRzLCBhZGRyLnpvbmVJZCk7XG4gICAgfTtcblxuICAgIGlwYWRkci5JUHY2LnBhcnNlQ0lEUiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgbGV0IG1hc2tMZW5ndGgsIG1hdGNoLCBwYXJzZWQ7XG5cbiAgICAgICAgaWYgKChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXiguKylcXC8oXFxkKykkLykpKSB7XG4gICAgICAgICAgICBtYXNrTGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbMl0pO1xuICAgICAgICAgICAgaWYgKG1hc2tMZW5ndGggPj0gMCAmJiBtYXNrTGVuZ3RoIDw9IDEyOCkge1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IFt0aGlzLnBhcnNlKG1hdGNoWzFdKSwgbWFza0xlbmd0aF07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnNlZCwgJ3RvU3RyaW5nJywge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuam9pbignLycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiBzdHJpbmcgaXMgbm90IGZvcm1hdHRlZCBsaWtlIGFuIElQdjYgQ0lEUiByYW5nZScpO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZSBhbiBJUHY2IGFkZHJlc3MuXG4gICAgaXBhZGRyLklQdjYucGFyc2VyID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICBsZXQgYWRkciwgaSwgbWF0Y2gsIG9jdGV0LCBvY3RldHMsIHpvbmVJZDtcblxuICAgICAgICBpZiAoKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjZSZWdleGVzLmRlcHJlY2F0ZWRUcmFuc2l0aW9uYWwpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VyKGA6OmZmZmY6JHttYXRjaFsxXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXB2NlJlZ2V4ZXMubmF0aXZlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZElQdjYoc3RyaW5nLCA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG1hdGNoID0gc3RyaW5nLm1hdGNoKGlwdjZSZWdleGVzLnRyYW5zaXRpb25hbCkpKSB7XG4gICAgICAgICAgICB6b25lSWQgPSBtYXRjaFs2XSB8fCAnJztcbiAgICAgICAgICAgIGFkZHIgPSBtYXRjaFsxXVxuICAgICAgICAgICAgaWYgKCFtYXRjaFsxXS5lbmRzV2l0aCgnOjonKSkge1xuICAgICAgICAgICAgICAgIGFkZHIgPSBhZGRyLnNsaWNlKDAsIC0xKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkciA9IGV4cGFuZElQdjYoYWRkciArIHpvbmVJZCwgNik7XG4gICAgICAgICAgICBpZiAoYWRkci5wYXJ0cykge1xuICAgICAgICAgICAgICAgIG9jdGV0cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQobWF0Y2hbMl0pLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChtYXRjaFszXSksXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KG1hdGNoWzRdKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQobWF0Y2hbNV0pXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2N0ZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG9jdGV0ID0gb2N0ZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgoMCA8PSBvY3RldCAmJiBvY3RldCA8PSAyNTUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhZGRyLnBhcnRzLnB1c2gob2N0ZXRzWzBdIDw8IDggfCBvY3RldHNbMV0pO1xuICAgICAgICAgICAgICAgIGFkZHIucGFydHMucHVzaChvY3RldHNbMl0gPDwgOCB8IG9jdGV0c1szXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHM6IGFkZHIucGFydHMsXG4gICAgICAgICAgICAgICAgICAgIHpvbmVJZDogYWRkci56b25lSWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIC8vIEEgdXRpbGl0eSBmdW5jdGlvbiB0byByZXR1cm4gc3VibmV0IG1hc2sgaW4gSVB2NiBmb3JtYXQgZ2l2ZW4gdGhlIHByZWZpeCBsZW5ndGhcbiAgICBpcGFkZHIuSVB2Ni5zdWJuZXRNYXNrRnJvbVByZWZpeExlbmd0aCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgcHJlZml4ID0gcGFyc2VJbnQocHJlZml4KTtcbiAgICAgICAgaWYgKHByZWZpeCA8IDAgfHwgcHJlZml4ID4gMTI4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lwYWRkcjogaW52YWxpZCBJUHY2IHByZWZpeCBsZW5ndGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9jdGV0cyA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBjb25zdCBmaWxsZWRPY3RldENvdW50ID0gTWF0aC5mbG9vcihwcmVmaXggLyA4KTtcblxuICAgICAgICB3aGlsZSAoaiA8IGZpbGxlZE9jdGV0Q291bnQpIHtcbiAgICAgICAgICAgIG9jdGV0c1tqXSA9IDI1NTtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxsZWRPY3RldENvdW50IDwgMTYpIHtcbiAgICAgICAgICAgIG9jdGV0c1tmaWxsZWRPY3RldENvdW50XSA9IE1hdGgucG93KDIsIHByZWZpeCAlIDgpIC0gMSA8PCA4IC0gKHByZWZpeCAlIDgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKG9jdGV0cyk7XG4gICAgfTtcblxuICAgIC8vIFRyeSB0byBwYXJzZSBhbiBhcnJheSBpbiBuZXR3b3JrIG9yZGVyIChNU0IgZmlyc3QpIGZvciBJUHY0IGFuZCBJUHY2XG4gICAgaXBhZGRyLmZyb21CeXRlQXJyYXkgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgaXBhZGRyLklQdjQoYnl0ZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gMTYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgaXBhZGRyLklQdjYoYnl0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IHRoZSBiaW5hcnkgaW5wdXQgaXMgbmVpdGhlciBhbiBJUHY2IG5vciBJUHY0IGFkZHJlc3MnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgdmFsaWQgSVAgYWRkcmVzc1xuICAgIGlwYWRkci5pc1ZhbGlkID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICByZXR1cm4gaXBhZGRyLklQdjYuaXNWYWxpZChzdHJpbmcpIHx8IGlwYWRkci5JUHY0LmlzVmFsaWQoc3RyaW5nKTtcbiAgICB9O1xuXG4gICAgLy8gQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIHZhbGlkIElQIGFkZHJlc3MgaW4gQ0lEUiBub3RhdGlvblxuICAgIGlwYWRkci5pc1ZhbGlkQ0lEUiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGlwYWRkci5JUHY2LmlzVmFsaWRDSURSKHN0cmluZykgfHwgaXBhZGRyLklQdjQuaXNWYWxpZENJRFIoc3RyaW5nKTtcbiAgICB9O1xuXG5cbiAgICAvLyBBdHRlbXB0cyB0byBwYXJzZSBhbiBJUCBBZGRyZXNzLCBmaXJzdCB0aHJvdWdoIElQdjYgdGhlbiBJUHY0LlxuICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiBpdCBjb3VsZCBub3QgYmUgcGFyc2VkLlxuICAgIGlwYWRkci5wYXJzZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgaWYgKGlwYWRkci5JUHY2LmlzVmFsaWQoc3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlwYWRkci5JUHY2LnBhcnNlKHN0cmluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXBhZGRyLklQdjQuaXNWYWxpZChzdHJpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXBhZGRyLklQdjQucGFyc2Uoc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXBhZGRyOiB0aGUgYWRkcmVzcyBoYXMgbmVpdGhlciBJUHY2IG5vciBJUHY0IGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEF0dGVtcHQgdG8gcGFyc2UgQ0lEUiBub3RhdGlvbiwgZmlyc3QgdGhyb3VnaCBJUHY2IHRoZW4gSVB2NC5cbiAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgY291bGQgbm90IGJlIHBhcnNlZC5cbiAgICBpcGFkZHIucGFyc2VDSURSID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGlwYWRkci5JUHY2LnBhcnNlQ0lEUihzdHJpbmcpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpcGFkZHIuSVB2NC5wYXJzZUNJRFIoc3RyaW5nKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpcGFkZHI6IHRoZSBhZGRyZXNzIGhhcyBuZWl0aGVyIElQdjYgbm9yIElQdjQgQ0lEUiBmb3JtYXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBQYXJzZSBhbiBhZGRyZXNzIGFuZCByZXR1cm4gcGxhaW4gSVB2NCBhZGRyZXNzIGlmIGl0IGlzIGFuIElQdjQtbWFwcGVkIGFkZHJlc3NcbiAgICBpcGFkZHIucHJvY2VzcyA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYWRkciA9IHRoaXMucGFyc2Uoc3RyaW5nKTtcblxuICAgICAgICBpZiAoYWRkci5raW5kKCkgPT09ICdpcHY2JyAmJiBhZGRyLmlzSVB2NE1hcHBlZEFkZHJlc3MoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZHIudG9JUHY0QWRkcmVzcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGFkZHI7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQW4gdXRpbGl0eSBmdW5jdGlvbiB0byBlYXNlIG5hbWVkIHJhbmdlIG1hdGNoaW5nLiBTZWUgZXhhbXBsZXMgYmVsb3cuXG4gICAgLy8gcmFuZ2VMaXN0IGNhbiBjb250YWluIGJvdGggSVB2NCBhbmQgSVB2NiBzdWJuZXQgZW50cmllcyBhbmQgd2lsbCBub3QgdGhyb3cgZXJyb3JzXG4gICAgLy8gb24gbWF0Y2hpbmcgSVB2NCBhZGRyZXNzZXMgdG8gSVB2NiByYW5nZXMgb3IgdmljZSB2ZXJzYS5cbiAgICBpcGFkZHIuc3VibmV0TWF0Y2ggPSBmdW5jdGlvbiAoYWRkcmVzcywgcmFuZ2VMaXN0LCBkZWZhdWx0TmFtZSkge1xuICAgICAgICBsZXQgaSwgcmFuZ2VOYW1lLCByYW5nZVN1Ym5ldHMsIHN1Ym5ldDtcblxuICAgICAgICBpZiAoZGVmYXVsdE5hbWUgPT09IHVuZGVmaW5lZCB8fCBkZWZhdWx0TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdE5hbWUgPSAndW5pY2FzdCc7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHJhbmdlTmFtZSBpbiByYW5nZUxpc3QpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmFuZ2VMaXN0LCByYW5nZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2VTdWJuZXRzID0gcmFuZ2VMaXN0W3JhbmdlTmFtZV07XG4gICAgICAgICAgICAgICAgLy8gRUNNQTUgQXJyYXkuaXNBcnJheSBpc24ndCBhdmFpbGFibGUgZXZlcnl3aGVyZVxuICAgICAgICAgICAgICAgIGlmIChyYW5nZVN1Ym5ldHNbMF0gJiYgIShyYW5nZVN1Ym5ldHNbMF0gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VTdWJuZXRzID0gW3JhbmdlU3VibmV0c107XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJhbmdlU3VibmV0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzdWJuZXQgPSByYW5nZVN1Ym5ldHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzLmtpbmQoKSA9PT0gc3VibmV0WzBdLmtpbmQoKSAmJiBhZGRyZXNzLm1hdGNoLmFwcGx5KGFkZHJlc3MsIHN1Ym5ldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByYW5nZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdE5hbWU7XG4gICAgfTtcblxuICAgIC8vIEV4cG9ydCBmb3IgYm90aCB0aGUgQ29tbW9uSlMgYW5kIGJyb3dzZXItbGlrZSBlbnZpcm9ubWVudFxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGlwYWRkcjtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuaXBhZGRyID0gaXBhZGRyO1xuICAgIH1cblxufSh0aGlzKSk7XG4iXSwibmFtZXMiOlsicm9vdCIsImlwdjRQYXJ0IiwiaXB2NFJlZ2V4ZXMiLCJmb3VyT2N0ZXQiLCJSZWdFeHAiLCJ0aHJlZU9jdGV0IiwidHdvT2N0ZXQiLCJsb25nVmFsdWUiLCJvY3RhbFJlZ2V4IiwiaGV4UmVnZXgiLCJ6b25lSW5kZXgiLCJpcHY2UGFydCIsImlwdjZSZWdleGVzIiwiZGVwcmVjYXRlZFRyYW5zaXRpb25hbCIsInRyYW5zaXRpb25hbCIsImV4cGFuZElQdjYiLCJzdHJpbmciLCJwYXJ0cyIsImluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImNvbG9uQ291bnQiLCJsYXN0Q29sb24iLCJ6b25lSWQiLCJtYXRjaCIsInJlcGxhY2VtZW50IiwicmVwbGFjZW1lbnRDb3VudCIsInN1YnN0cmluZyIsInJlcGxhY2UiLCJzdWJzdHIiLCJzbGljZSIsImxlbmd0aCIsInJlZiIsInNwbGl0IiwicmVzdWx0cyIsImkiLCJwdXNoIiwicGFyc2VJbnQiLCJtYXRjaENJRFIiLCJmaXJzdCIsInNlY29uZCIsInBhcnRTaXplIiwiY2lkckJpdHMiLCJFcnJvciIsInBhcnQiLCJzaGlmdCIsInBhcnNlSW50QXV0byIsInRlc3QiLCJpc05hTiIsInBhZFBhcnQiLCJpcGFkZHIiLCJJUHY0Iiwib2N0ZXRzIiwib2N0ZXQiLCJwcm90b3R5cGUiLCJTcGVjaWFsUmFuZ2VzIiwidW5zcGVjaWZpZWQiLCJicm9hZGNhc3QiLCJtdWx0aWNhc3QiLCJsaW5rTG9jYWwiLCJsb29wYmFjayIsImNhcnJpZXJHcmFkZU5hdCIsInJlc2VydmVkIiwiYXMxMTIiLCJhbXQiLCJraW5kIiwib3RoZXIiLCJjaWRyUmFuZ2UiLCJ1bmRlZmluZWQiLCJwcmVmaXhMZW5ndGhGcm9tU3VibmV0TWFzayIsImNpZHIiLCJzdG9wIiwiemVyb3RhYmxlIiwiemVyb3MiLCJyYW5nZSIsInN1Ym5ldE1hdGNoIiwidG9CeXRlQXJyYXkiLCJ0b0lQdjRNYXBwZWRBZGRyZXNzIiwiSVB2NiIsInBhcnNlIiwidG9TdHJpbmciLCJ0b05vcm1hbGl6ZWRTdHJpbmciLCJqb2luIiwiYnJvYWRjYXN0QWRkcmVzc0Zyb21DSURSIiwicGFyc2VDSURSIiwiaXBJbnRlcmZhY2VPY3RldHMiLCJzdWJuZXRNYXNrT2N0ZXRzIiwic3VibmV0TWFza0Zyb21QcmVmaXhMZW5ndGgiLCJlIiwiaXNJUHY0IiwicGFyc2VyIiwiaXNWYWxpZCIsImlzVmFsaWRDSURSIiwiaXNWYWxpZEZvdXJQYXJ0RGVjaW1hbCIsIm5ldHdvcmtBZGRyZXNzRnJvbUNJRFIiLCJtYXNrTGVuZ3RoIiwicGFyc2VkIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsInJldmVyc2UiLCJwcmVmaXgiLCJqIiwiZmlsbGVkT2N0ZXRDb3VudCIsIk1hdGgiLCJmbG9vciIsInBvdyIsInVuaXF1ZUxvY2FsIiwiaXB2NE1hcHBlZCIsImRpc2NhcmQiLCJyZmM2MTQ1IiwicmZjNjA1MiIsInRlcmVkbyIsImJlbmNobWFya2luZyIsImFzMTEydjYiLCJkZXByZWNhdGVkIiwib3JjaGlkMiIsImRyb25lUmVtb3RlSWRQcm90b2NvbEVudGl0eVRhZ3MiLCJpc0lQdjRNYXBwZWRBZGRyZXNzIiwiYnl0ZXMiLCJ0b0ZpeGVkTGVuZ3RoU3RyaW5nIiwiYWRkciIsImNhbGwiLCJzdWZmaXgiLCJ0b0lQdjRBZGRyZXNzIiwiaGlnaCIsImxvdyIsInRvUkZDNTk1MlN0cmluZyIsInJlZ2V4IiwiYmVzdE1hdGNoSW5kZXgiLCJiZXN0TWF0Y2hMZW5ndGgiLCJleGVjIiwiaW5kZXgiLCJpc0lQdjYiLCJuYXRpdmUiLCJlbmRzV2l0aCIsImZyb21CeXRlQXJyYXkiLCJlMiIsInByb2Nlc3MiLCJhZGRyZXNzIiwicmFuZ2VMaXN0IiwiZGVmYXVsdE5hbWUiLCJyYW5nZU5hbWUiLCJyYW5nZVN1Ym5ldHMiLCJzdWJuZXQiLCJoYXNPd25Qcm9wZXJ0eSIsIkFycmF5IiwiYXBwbHkiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ipaddr.js/lib/ipaddr.js\n");

/***/ })

};
;